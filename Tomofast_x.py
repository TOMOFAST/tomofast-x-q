# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Tomofast_x
                                 A QGIS plugin
 Supprts Tomofast-x geophysical inversion code
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by uwa.edu.au
        email                : mark.jessell@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import (
    Qgis,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsVectorLayer,
    QgsProject,
    QgsRasterLayer,
    QgsFeature,
    QgsField,
    QgsVectorFileWriter,
    QgsPoint,
)
from qgis.PyQt.QtCore import (
    QSettings,
    QTranslator,
    QCoreApplication,
    QFileInfo,
    QVariant,
    Qt,
)
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsField,
    QgsPointXY,
    QgsGeometry,
    QgsFeature,
    QgsFields,
    QgsRasterLayer,
)
from qgis.core import (
    QgsRendererRangeLabelFormat,
    QgsStyle,
    QgsGraduatedSymbolRenderer,
    QgsClassificationEqualInterval,
    QgsSymbol,
)
from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog

# import functions from scripts
from .Data2Tomofast import Data2Tomofast
import numpy as np
import pandas as pd
from osgeo import gdal
import processing
from qgis.PyQt.QtWidgets import QApplication
from qgis.PyQt.QtCore import Qt
import os
from pyproj import Transformer
from .ppigrf import igrf, get_inclination_declination
from datetime import datetime
import subprocess
import shlex
import platform
import sys
import shutil

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .Tomofast_x_dockwidget import Tomofast_xDockWidget
import os.path


class Tomofast_x:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = str(QSettings().value("locale/userLocale"))[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "Tomofast_x_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Tomofast_x")
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar("Tomofast_x")
        self.toolbar.setObjectName("Tomofast_x")

        # print "** INITIALIZING Tomofast_x"

        self.pluginIsActive = False
        self.dlg = None

        self.initialise_variables()

    def define_parameters(self):

        #   set up dict with form
        #
        #   key=parfile variable name
        #   values=p[0] variable contents,
        #          p[1] associated widget(s),
        #          p[-2] data type,
        #          p[-1] widget type

        self.d_params = {
            # GLOBAL
            "global.outputFolderPath": [
                self.global_outputFolderPath,
                self.dlg.lineEdit_output_directory_path,
                str,
                "text",
            ],
            "global.description": [
                self.global_description,
                self.dlg.textEdit_experiment_description,
                str,
                "plainText",
            ],
            "global.experimentType": [
                self.global_experimentType,
                self.dlg.radioButton_grav_inv,
                self.dlg.radioButton_magn_inv,
                self.dlg.radioButton_joint_inv,
                int,
                "radio",
            ],
            """"global.elevType": [
                self.global_elevType,
                self.dlg.radioButton_elev_const,
                self.dlg.radioButton_elev_dtm,
                int,
                "radio",
            ],"""
            "global.elevFilename": [
                self.global_elevFilename,
                self.dlg.lineEdit_dtm_path,
                str,
                "text",
            ],
            # DATA Parameters
            "anomalies.grav.data.file": [
                self.filename_grav,
                self.dlg.lineEdit_grav_data_path,
                str,
                "text",
            ],
            "anomalies.magn.data.file": [
                self.filename_magn,
                self.dlg.lineEdit_magn_data_path,
                str,
                "text",
            ],
            "anomalies.grav.proj.in": [
                self.grav_proj_in,
                self.dlg.mQgsProjectionSelectionWidget_grav_in,
                str,
                "epsg",
            ],
            "anomalies.grav.proj.out": [
                self.grav_proj_out,
                self.dlg.mQgsProjectionSelectionWidget_grav_out,
                str,
                "epsg",
            ],
            "anomalies.magn.proj.in": [
                self.magn_proj_in,
                self.dlg.mQgsProjectionSelectionWidget_magn_in,
                str,
                "epsg",
            ],
            "anomalies.magn.proj.out": [
                self.magn_proj_out,
                self.dlg.mQgsProjectionSelectionWidget_magn_out,
                str,
                "epsg",
            ],
            "forward.data.grav.dataGridFile": [
                self.forward_data_grav_dataGridFile,
                "",
                str,
                "path",
            ],
            "forward.data.magn.dataGridFile": [
                self.forward_data_magn_dataGridFile,
                "",
                str,
                "path",
            ],
            "forward.data.grav.dataValuesFile": [
                self.forward_data_grav_dataValuesFile,
                "",
                str,
                "path",
            ],
            "forward.data.magn.dataValuesFile": [
                self.forward_data_magn_dataValuesFile,
                "",
                str,
                "path",
            ],
            "modelGrid.size": [
                self.modelGrid_size,
                self.dlg.nx_label,
                self.dlg.ny_label,
                self.dlg.nz_label,
                str,
                "size",
            ],
            "forward.data.grav.nData": [self.forward_data_grav_nData, "", int, "ndata"],
            "forward.data.magn.nData": [self.forward_data_magn_nData, "", int, "ndata"],
            # MODEL GRID parameters
            "anomalies.grav.data_file": [
                self.modelGrid_grav_file,
                self.dlg.lineEdit_grav_data_path,
                str,
                "text",
            ],
            "anomalies.magn.data_file": [
                self.modelGrid_magn_file,
                self.dlg.lineEdit_magn_data_path,
                str,
                "text",
            ],
            # DEPTH WEIGHTING
            "forward.depthWeighting.grav.type": [
                self.forward_depthWeighting_grav_type,
                self.dlg.checkBox_grav_depth_weighting,
                int,
                "check",
            ],
            "forward.depthWeighting.magn.type": [
                self.forward_depthWeighting_magn_type,
                self.dlg.checkBox_magn_depth_weighting,
                int,
                "check",
            ],
            "forward.depthWeighting.grav.power": [
                self.forward_depthWeighting_grav_power,
                self.dlg.mQgsDoubleSpinBox_grav_depth_weight_power,
                float,
                "value",
            ],
            "forward.depthWeighting.magn.power": [
                self.forward_depthWeighting_magn_power,
                self.dlg.mQgsDoubleSpinBox_mag_depth_weighting,
                float,
                "value",
            ],
            # SENSITIVITY KERNEL
            "sensit.readFromFiles": [
                self.sensit_readFromFiles,
                self.dlg.checkBox_read_sens_matrix,
                int,
                "check",
            ],
            # MATRIX COMPRESSION
            "forward.matrixCompression.type": [
                self.forward_matrixCompression_type,
                self.dlg.checkBox_use_compression,
                int,
                "check",
            ],
            "forward.matrixCompression.rate": [
                self.forward_matrixCompression_rate,
                self.dlg.mQgsDoubleSpinBox_compression_ratio,
                float,
                "value",
            ],
            # INVERSION parameters
            "inversion.nMajorIterations": [
                self.inversion_nMajorIterations,
                self.dlg.mQgsSpinBox_major_iters,
                int,
                "value",
            ],
            "inversion.nMinorIterations": [
                self.inversion_nMinorIterations,
                self.dlg.mQgsSpinBox_minor_iters,
                int,
                "value",
            ],
            "inversion.writeModelEveryNiter": [
                self.inversion_writeModelEveryNiter,
                self.dlg.mQgsSpinBox_model_save_iters,
                int,
                "value",
            ],
            # "inversion.minResidual" : [self.inversion_minResidual,self.dlg.textEdit_min_residual,str,'plainText'],
            # MODEL DAMPING (m - m_prior)
            "inversion.modelDamping.grav.weight": [
                self.inversion_modelDamping_grav_weight,
                self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight,
                float,
                "value",
            ],
            "inversion.modelDamping.grav.normPower": [
                self.inversion_modelDamping_grav_normPower,
                self.dlg.mQgsDoubleSpinBox_grav_mmodel_norm_power,
                float,
                "value",
            ],
            "inversion.modelDamping.magn.weight": [
                self.inversion_modelDamping_magn_weight,
                self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight,
                float,
                "value",
            ],
            "inversion.modelDamping.magn.normPower": [
                self.inversion_modelDamping_magn_normPower,
                self.dlg.mQgsDoubleSpinBox_grav_mmodel_norm_power,
                float,
                "value",
            ],
            # JOINT INVERSION parameters
            "inversion.joint.grav.problemWeight": [
                self.inversion_joint_grav_problemWeight,
                self.dlg.mQgsDoubleSpinBox_grav_weight,
                float,
                "value",
            ],
            "inversion.joint.magn.problemWeight": [
                self.inversion_joint_magn_problemWeight,
                self.dlg.mQgsDoubleSpinBox_magn_weight,
                float,
                "value",
            ],
            # ADMM constraints
            "inversion.admm.grav.enableADMM": [
                self.inversion_admm_grav_enableADMM,
                self.dlg.radioButton_grav_depth_based_ADMM,
                self.dlg.radioButton_grav_dist_based_ADMM,
                int,
                "radio",
            ],
            "inversion.admm.grav.nLithologies": [
                self.inversion_admm_grav_nLithologies,
                self.dlg.spinBox_grav_number_ADMM_litho,
                int,
                "value",
            ],
            "inversion.admm.grav.bounds": [
                self.inversion_admm_grav_bounds,
                self.dlg.textEdit_grav_ADMM_bounds,
                str,
                "plainText",
            ],
            "inversion.admm.grav.weight": [
                self.inversion_admm_grav_weight,
                self.dlg.lineEdit_grav_ADMM_weight,
                str,
                "text",
            ],
            "inversion.admm.magn.enableADMM": [
                self.inversion_admm_magn_enableADMM,
                self.dlg.radioButton_magn_ADMM_dist_based,
                self.dlg.radioButton_magn_ADMM_depth_based,
                int,
                "radio",
            ],
            "inversion.admm.magn.nLithologies": [
                self.inversion_admm_magn_nLithologies,
                self.dlg.spinBox_magn_ADMM_number_litho,
                int,
                "value",
            ],
            "inversion.admm.magn.bounds": [
                self.inversion_admm_magn_bounds,
                self.dlg.textEdit_5_magn_ADMM_bounds,
                str,
                "plainText",
            ],
            "inversion.admm.magn.weight": [
                self.inversion_admm_magn_weight,
                self.dlg.lineEdit_magn_ADMM_weight,
                str,
                "text",
            ],
            # MULTIPLIERS
            "global.grav.dataUnitsMultiplier": [
                self.global_grav_dataUnitsMultiplier,
                self.dlg.mQgsDoubleSpinBox_grav_data_multiplier,
                float,
                "value",
            ],
            "global.grav.modelUnitsMultiplier": [
                self.global_grav_modelUnitsMultiplier,
                self.dlg.mQgsDoubleSpinBox_grav_model_multiplier,
                float,
                "value",
            ],
            "global.magn.dataUnitsMultiplier": [
                self.global_magn_dataUnitsMultiplier,
                self.dlg.mQgsDoubleSpinBox_magn_data_multiplier,
                float,
                "value",
            ],
            "global.grav.sensor_height": [
                self.global_grav_sensor_height,
                self.dlg.doubleSpinBox_grav_sensor_height,
                float,
                "value",
            ],
            "global.magn.sensor_height": [
                self.global_magn_sensor_height,
                self.dlg.doubleSpinBox_magn_sensor_height,
                float,
                "value",
            ],
            # MESH
            "mesh.cellx": [self.cell_x, self.dlg.mQgsSpinBox_mesh_size_x, int, "value"],
            "mesh.celly": [self.cell_y, self.dlg.mQgsSpinBox_mesh_size_y, int, "value"],
            "mesh.cellz": [self.dz, self.dlg.mQgsSpinBox_mesh_size_z, float, "value"],
            "mesh.z.coreDepth": [
                self.z_coreDepth,
                self.dlg.doubleSpinBox_coreDepth,
                float,
                "value",
            ],
            "mesh.z.fullDepth": [
                self.z_fullDepth,
                self.dlg.doubleSpinBox_fullDepth,
                float,
                "value",
            ],
            "mesh.padding": [
                self.padding,
                self.dlg.mQgsSpinBox_mesh_padding,
                int,
                "value",
            ],
            # Mag Field
            "forward.magneticField.declination": [
                self.forward_magneticField_declination,
                self.dlg.doubleSpinBox_mag_dec,
                float,
                "value",
            ],
            "forward.magneticField.inclination": [
                self.forward_magneticField_inclination,
                self.dlg.doubleSpinBox_mag_inc,
                float,
                "value",
            ],
            "forward.magneticField.intensity": [
                self.forward_magneticField_intensity,
                self.dlg.doubleSpinBox_mag_int,
                float,
                "value",
            ],
        }

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("Tomofast_x", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/Tomofast_x/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("Tomofast_x"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # print "** CLOSING Tomofast_x"

        # disconnects
        self.dlg.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dlg = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        # print "** UNLOAD Tomofast_x"

        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Tomofast_x"), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True


            # print "** STARTING Tomofast_x"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dlg == None:
                # Create the dockwidget (after translation) and keep reference
                self.dlg = Tomofast_xDockWidget()

            if platform.system() == "Darwin":
                self.dlg.lineEdit_2_mpirunPath_2.setEnabled(True) 
                self.dlg.lineEdit_pre_command.setEnabled(False)
                self.dlg.lineEdit_pre_command_2_WSL_Distro.setEnabled(False)
            elif platform.system() == "Windows":
                self.dlg.lineEdit_2_mpirunPath_2.setEnabled(False) 
                self.dlg.lineEdit_pre_command.setEnabled(True)
                self.dlg.lineEdit_pre_command_2_WSL_Distro.setEnabled(True)
            else: # Linux
                self.dlg.lineEdit_2_mpirunPath_2.setEnabled(False) 
                self.dlg.lineEdit_pre_command.setEnabled(False)
                self.dlg.lineEdit_pre_command_2_WSL_Distro.setEnabled(False)

            # connect to provide cleanup on closing of dockwidget
            self.dlg.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dlg)
            # Find existing dock widgets in the right area
            right_docks = [
                d
                for d in self.iface.mainWindow().findChildren(QDockWidget)
                if self.iface.mainWindow().dockWidgetArea(d) == Qt.RightDockWidgetArea
            ]
            # If there are other dock widgets, tab this one with the first one found
            if right_docks:
                for dock in right_docks:
                    if dock != self.dlg:
                        self.iface.mainWindow().tabifyDockWidget(dock, self.dlg)
                        # Optionally, bring your plugin tab to the front
                        self.dlg.raise_()
                        break
            self.dlg.show()
            self.define_tips()
            self.dlg.mQgsProjectionSelectionWidget_grav_in.setCrs(
                QgsCoordinateReferenceSystem("EPSG:4326")
            )
            self.dlg.mQgsProjectionSelectionWidget_grav_out.setCrs(
                QgsCoordinateReferenceSystem("EPSG:4326")
            )
            self.dlg.mQgsProjectionSelectionWidget_magn_in.setCrs(
                QgsCoordinateReferenceSystem("EPSG:4326")
            )
            self.dlg.mQgsProjectionSelectionWidget_magn_out.setCrs(
                QgsCoordinateReferenceSystem("EPSG:4326")
            )

            self.dlg.doubleSpinBox_coreDepth.setEnabled(False)
            self.dlg.doubleSpinBox_fullDepth.setEnabled(False)

            self.dlg.radioButton_magn_inv.setChecked(False)
            self.dlg.pushButton_reset.setEnabled(True)

            self.dlg.pushButton_calc_IGRF.clicked.connect(self.update_mag_field)
            self.dlg.pushButton_load_grav_data.clicked.connect(
                lambda: self.confirm_data_file("grav")
            )
            self.dlg.pushButton_load_magn_data.clicked.connect(
                lambda: self.confirm_data_file("magn")
            )
            self.dlg.pushButton_save_paramfile.clicked.connect(self.save_parameter_file)
            self.dlg.pushButton_grav_data_path.clicked.connect(
                lambda: self.select_data_file("grav")
            )
            self.dlg.pushButton_magn_data_path.clicked.connect(
                lambda: self.select_data_file("magn")
            )
            self.dlg.pushButton_assign_grav_fields.clicked.connect(
                self.process_data_fields_grav
            )
            self.dlg.pushButton_assign_magn_fields.clicked.connect(
                self.process_data_fields_magn
            )
            self.dlg.lineEdit_output_directory_path_select.clicked.connect(
                self.select_ouput_directory
            )
            self.dlg.pushButton_select_dtm_path.clicked.connect(self.select_dtm)
            self.dlg.pushButton_param_load_path.clicked.connect(
                self.process_parameter_file
            )
            self.dlg.lineEdit_ROI_path_select.clicked.connect(self.load_ROI)

            self.dlg.radioButton_grav_inv.toggled.connect(self.inversion_type)
            self.dlg.radioButton_magn_inv.toggled.connect(self.inversion_type)
            self.dlg.radioButton_joint_inv.toggled.connect(self.inversion_type)

            self.dlg.doubleSpinBox_coreDepth.valueChanged.connect(self.mesh_layers)
            self.dlg.doubleSpinBox_fullDepth.valueChanged.connect(self.mesh_layers)

            # updating model grid size
            self.dlg.mQgsSpinBox_mesh_south.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_north.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_east.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_west.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_size_x.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_size_y.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_size_z.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_padding.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.mQgsSpinBox_mesh_padding.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.doubleSpinBox_coreDepth.valueChanged.connect(
                self.update_model_grid_size
            )
            self.dlg.doubleSpinBox_fullDepth.valueChanged.connect(
                self.update_model_grid_size
            )

            self.dlg.mQgsDoubleSpinBox_compression_ratio.valueChanged.connect(
                self.update_memory_size
            )
            self.dlg.checkBox_use_compression.toggled.connect(self.update_memory_size)

            self.dlg.pushButton_reset.clicked.connect(self.reset_params)

            self.dlg.pushButton_select_tomoPath.clicked.connect(self.select_tomo_Path)
            self.dlg.pushButton_2_select_parfilePath.clicked.connect(
                self.select_paramfile_path
            )

            self.dlg.pushButton_3_runInversion.clicked.connect(self.run_inversion)

            self.define_parameters()
            if os.path.exists(
                os.path.dirname(os.path.realpath(__file__)) + "/tomoconfig.txt"
            ):
                with open(
                    os.path.dirname(os.path.realpath(__file__)) + "/tomoconfig.txt", "r"
                ) as tpfile:
                    line = tpfile.readline()
                    self.tomo_Path = line.rstrip()
                    self.dlg.lineEdit_tomoPath.setText(self.tomo_Path)

                    line = tpfile.readline()
                    self.dlg.lineEdit_pre_command_2_WSL_Distro.setText(line.rstrip())

                    line = tpfile.readline()
                    self.dlg.lineEdit_pre_command.setText(line.rstrip())

                    line = tpfile.readline()
                    self.dlg.lineEdit_2_mpirunPath_2.setText(line.rstrip())

            self.dlg.version_label.setText("v " + self.show_version())

        # result = self.dlg.exec_()

    def replace_text_in_file(self, file_path, old_text, new_text):
        """
        Replace all occurrences of a specific text in a file with new text.

        Parameters:
            file_path (str): Path to the file.
            old_text (str): Text to be replaced.
            new_text (str): Replacement text.

        Returns:
            None
        """
        try:
            # Open the file for reading
            with open(file_path, "r", encoding="utf-8") as file:
                content = file.read()

            # Replace all occurrences of old_text with new_text
            updated_content = content.replace(old_text, new_text)

            # Open the file for writing and save the updated content
            with open(file_path, "w", encoding="utf-8") as file:
                file.write(updated_content)

        except FileNotFoundError:
            print(f"File not found: {file_path}")
        except Exception as e:
            print(f"An error occurred: {e}")

    def run_inversion(self):
        if (
            os.path.exists(self.paramfile_Path)
            and self.paramfile_Path != ""
            and os.path.exists(self.tomo_Path)
            and self.tomo_Path != ""
        ):
            if platform.system() == "Windows":
                self.paramfile_Path_run = self.paramfile_Path + "_run"
                shutil.copyfile(self.paramfile_Path, self.paramfile_Path_run)
                self.replace_text_in_file(self.paramfile_Path_run, "= C:/", "= /mnt/c/")
                distro = self.dlg.lineEdit_pre_command_2_WSL_Distro.text()
                wsl_path = "//wsl.localhost/" + distro
                wsl_param_path = self.paramfile_Path_run.replace("C:/", "/mnt/c/")
                wsl_tomo_path = self.tomo_Path.replace(wsl_path, "")
                pre_command = self.dlg.lineEdit_pre_command.text()
                mpirun_path = " mpirun "

            elif platform.system() == "Darwin":
                wsl_tomo_path = self.tomo_Path
                wsl_param_path = self.paramfile_Path
                pre_command = ""
                mpirun_path = " "+self.dlg.lineEdit_2_mpirunPath_2.text().strip()+" "
                distro = " "

            else:
                wsl_tomo_path = self.tomo_Path
                wsl_param_path = self.paramfile_Path
                pre_command = ""
                mpirun_path = " mpirun "
                distro = " "

            if os.path.exists(self.tomo_Path) and self.tomo_Path != "":
                self.dlg.lineEdit_tomoPath.setText(self.tomo_Path)
                with open(
                    os.path.dirname(os.path.realpath(__file__)) + "/tomoconfig.txt",
                    "w",
                ) as tpfile:
                    tpfile.write(self.tomo_Path + "\n")
                    tpfile.write(distro + "\n")
                    tpfile.write(pre_command + "\n")
                    tpfile.write(mpirun_path + "\n") 

            noProc = self.dlg.mQgsSpinBox_noProc.value()
            # Path to your executable
            if noProc == 1:
                command = pre_command + " " + wsl_tomo_path + " -j " + wsl_param_path
            else:
                command = (
                    pre_command
                    + mpirun_path
                    + " -np "
                    + str(noProc)
                    + " "
                    + wsl_tomo_path
                    + " -j "
                    + wsl_param_path
                )
            args = shlex.split(command)

            # set system/version dependent "start_new_session" analogs
            kwargs = {}
            if platform.system() == "Windows":
                # from msdn [1]
                CREATE_NEW_PROCESS_GROUP = (
                    0x00000200  # note: could get it from subprocess
                )
                DETACHED_PROCESS = 0x00000008  # 0x8 | 0x200 == 0x208
                kwargs.update(creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP)
            elif sys.version_info < (3, 2):  # assume posix
                kwargs.update(preexec_fn=os.setsid)
            else:  # Python 3.2+ and Unix
                kwargs.update(start_new_session=True)

            try:
                # Open a subprocess to execute the command
                process = subprocess.Popen(
                    args,
                    shell=False,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    stdin=subprocess.PIPE,  # Redirect standard input (optional)
                    close_fds=True,
                    **kwargs,
                )
                print("process", process)
                # Print the process ID for tracking
                self.iface.messageBar().pushMessage(
                    f"Process started with PID: {process.pid}",
                    "Command is running in the background ",
                    level=Qgis.Success,
                    duration=45,
                )
            except Exception as e:
                print(f"An error occurred: {e}")
        else:
            self.iface.messageBar().pushMessage(
                f"Paths to tomofastx and paramfile must be defined",
                level=Qgis.Warning,
                duration=15,
            )

    def select_tomo_Path(self):

        self.tomo_Path, _filter = QFileDialog.getOpenFileName(
            None,
            "Select tomofast executable",
            ".",
            # "CSV (*.csv;*.CSV);;GRD (*.GRD;*.grd);;TIF (*.TIF;*.tif;*.TIFF;*.tiff)",
            "All (*)",
        )

    def select_paramfile_path(self):

        self.paramfile_Path, _filter = QFileDialog.getOpenFileName(
            None,
            "Select tomofast paramfile",
            ".",
            # "CSV (*.csv;*.CSV);;GRD (*.GRD;*.grd);;TIF (*.TIF;*.tif;*.TIFF;*.tiff)",
            "All (*.*)",
        )
        if os.path.exists(self.paramfile_Path) and self.paramfile_Path != "":
            self.dlg.lineEdit_2_parfilePath.setText(self.paramfile_Path)

    # load and parse existing paramfiel and set gui widgets accordingly
    def process_parameter_file(self):

        self.select_parfile()
        if self.parfilename != "" and os.path.exists(self.parfilename):
            self.load_parfile()
            self.enable_boxes()
            self.parse_parameters()

            self.iface.messageBar().pushMessage(
                "Parfile loaded ", "OK ", level=Qgis.Success, duration=45
            )

    # select existing parfile
    def select_parfile(self):

        self.parfilename, _filter = QFileDialog.getOpenFileName(
            None, "Select Parameter File", ".", "TXT (*.txt)"
        )
        self.dlg.lineEdit_param_load_path.setText(self.parfilename)

    # select existing ROI shapefile
    def load_ROI(self):

        self.ROIFileName, _filter = QFileDialog.getOpenFileName(
            None, "Select ROI File", ".", "SHP (*.shp)"
        )
        self.dlg.lineEdit_ROI_path.setText(self.ROIFileName)
        layer = QgsVectorLayer(self.ROIFileName, "ROI", "ogr")
        if layer.isValid():
            if self.global_experimentType == 1 or self.global_experimentType == 3:
                proj = self.grav_proj_out
            else:
                proj = self.magn_proj_out

            parameter = {
                "INPUT": layer,
                "TARGET_CRS": proj,
                "OUTPUT": "memory:{}_Reprojected".format("ROI"),
            }
            result = processing.run("native:reprojectlayer", parameter)["OUTPUT"]

            QgsProject.instance().addMapLayer(result)

            # Use the coordinates of the bounding box as limits of mesh (without padding)
            self.data_extents(result)

    def select_data_file(self, dataType):

        filename, _filter = QFileDialog.getOpenFileName(
            None,
            "Select Data File",
            ".",
            # "CSV (*.csv;*.CSV);;GRD (*.GRD;*.grd);;TIF (*.TIF;*.tif;*.TIFF;*.tiff)",
            "Point/grid (*.csv *.CSV *.TIF *.tif *.TIFF *.tiff *.ERS *.ers)",
        )
        if os.path.exists(filename) and filename != "":
            if dataType == "grav":
                self.dlg.lineEdit_grav_data_path.setText(filename)
                self.dlg.pushButton_load_grav_data.setEnabled(True)
                self.filename_grav = filename
            else:
                self.dlg.lineEdit_magn_data_path.setText(filename)
                self.dlg.pushButton_load_magn_data.setEnabled(True)
                self.filename_magn = filename

    # select existing point or raster magn data
    def select_dtm(self):
        self.dtm_filename, _filter = QFileDialog.getOpenFileName(
            None, "Select DTM File", ".", "TIFF (*.tif)"
        )

        self.dlg.lineEdit_dtm_path.setText(self.dtm_filename)

        if self.dtm_filename != "" and os.path.exists(self.dtm_filename):
            self.load_dtm()
            self.global_elevFilename = self.dtm_filename
            self.global_elevType = 2

    # process input grav data and update gui to allow next stage of data to be defined
    def confirm_data_file(self, dataType):
        self.process_data_file()

        if dataType == "grav":
            self.grav_proj_in = (
                self.dlg.mQgsProjectionSelectionWidget_grav_in.crs().authid()
            )
            self.grav_proj_out = (
                self.dlg.mQgsProjectionSelectionWidget_grav_out.crs().authid()
            )
            suffix = self.dlg.lineEdit_grav_data_path.text().split(".")[-1]
        else:
            self.magn_proj_in = (
                self.dlg.mQgsProjectionSelectionWidget_magn_in.crs().authid()
            )
            self.magn_proj_out = (
                self.dlg.mQgsProjectionSelectionWidget_magn_out.crs().authid()
            )
            suffix = self.dlg.lineEdit_magn_data_path.text().split(".")[-1]

        if suffix.lower() == "csv":
            self.global_dataType = "points"
        else:
            self.global_dataType = "raster"

        # enable GroupBox 9
        if self.global_dataType == "points":
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.label_44.setEnabled(True)
            self.dlg.label_45.setEnabled(True)
            self.dlg.label_47.setEnabled(True)
            if dataType == "grav":
                self.dlg.comboBox_grav_field_x.setEnabled(True)
                self.dlg.comboBox_grav_field_y.setEnabled(True)
                self.dlg.comboBox_grav_field_data.setEnabled(True)
                self.dlg.pushButton_assign_grav_fields.setEnabled(True)
            else:
                self.dlg.comboBox_magn_field_x.setEnabled(True)
                self.dlg.comboBox_magn_field_y.setEnabled(True)
                self.dlg.comboBox_magn_field_data.setEnabled(True)
                self.dlg.pushButton_assign_magn_fields.setEnabled(True)

            self.dlg.pushButton_select_dtm_path.setEnabled(False)
        else:
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.lineEdit_dtm_path.setEnabled(False)
            self.dlg.pushButton_select_dtm_path.setEnabled(False)

            self.update_widgets()

    # process input grav data and update gui to allow next stage of data to be defined
    def confirm_data_file_grav(self):
        self.process_data_file()
        self.grav_proj_in = (
            self.dlg.mQgsProjectionSelectionWidget_grav_in.crs().authid()
        )
        self.grav_proj_out = (
            self.dlg.mQgsProjectionSelectionWidget_grav_out.crs().authid()
        )

        suffix = self.dlg.lineEdit_grav_data_path.text().split(".")[-1]
        if suffix.lower() == "csv":
            self.global_dataType = "points"
        else:
            self.global_dataType = "raster"

        # enable GroupBox 9
        if self.global_dataType == "points":
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.label_44.setEnabled(True)
            self.dlg.label_45.setEnabled(True)
            self.dlg.label_47.setEnabled(True)
            self.dlg.comboBox_grav_field_x.setEnabled(True)
            self.dlg.comboBox_grav_field_y.setEnabled(True)
            self.dlg.comboBox_grav_field_data.setEnabled(True)
            self.dlg.pushButton_assign_grav_fields.setEnabled(True)
            self.dlg.pushButton_select_dtm_path.setEnabled(False)
        else:
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.lineEdit_dtm_path.setEnabled(False)
            self.dlg.pushButton_select_dtm_path.setEnabled(False)

            self.update_widgets()

    # process input magn data and update gui to allow next stage of data to be defined
    def confirm_data_file_mag(self):
        self.process_data_file()
        self.magn_proj_in = (
            self.dlg.mQgsProjectionSelectionWidget_magn_in.crs().authid()
        )
        self.magn_proj_out = (
            self.dlg.mQgsProjectionSelectionWidget_magn_out.crs().authid()
        )
        suffix = self.dlg.lineEdit_magn_data_path.text().split(".")[-1]
        if suffix.lower() == "csv":
            self.global_dataType = "points"
        else:
            self.global_dataType = "raster"

        # enable GroupBox 10
        if self.global_dataType == "points":
            self.dlg.groupBox_10.setEnabled(True)
            self.dlg.label_77.setEnabled(True)
            self.dlg.label_78.setEnabled(True)
            self.dlg.label_82.setEnabled(True)
            self.dlg.comboBox_magn_field_x.setEnabled(True)
            self.dlg.comboBox_magn_field_y.setEnabled(True)
            self.dlg.comboBox_magn_field_data.setEnabled(True)
            self.dlg.pushButton_assign_magn_fields.setEnabled(True)
            self.dlg.lineEdit_ROI_path_select.setEnabled(True)
            self.dlg.lineEdit_ROI_path.setEnabled(True)
        else:
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.lineEdit_dtm_path.setEnabled(False)
            self.dlg.pushButton_select_dtm_path.setEnabled(False)
            self.dlg.lineEdit_ROI_path_select.setEnabled(True)
            self.dlg.lineEdit_ROI_path.setEnabled(True)
            self.update_widgets()

    # process load grav data, update gui and display as layer
    def process_data_fields_grav(self):
        self.update_widgets()
        self.load_csv_vector_grav(
            self.filename_grav, self.xcol_grav, self.ycol_grav, self.datacol_grav
        )

    # process load magn data, update gui and display as layer
    def process_data_fields_magn(self):
        self.update_widgets()
        self.load_csv_vector_magn(
            self.filename_magn, self.xcol_magn, self.ycol_magn, self.datacol_magn
        )

    # estimate mag field from centroid of data, date and sensor height
    def update_mag_field(self):

        # retrieve parameters
        self.magn_SurveyHeight = self.dlg.doubleSpinBox_magn_sensor_height.value()
        date_text = str(self.dlg.dateEdit.date().toPyDate())

        date_split = date_text.split("-")
        self.magn_SurveyDay = date_split[2]
        self.magn_SurveyMonth = date_split[1]
        self.magn_SurveyYear = date_split[0]
        date = datetime(2021, 3, 28)

        # calculate midpoint of mesh
        midx = self.meshBox["west"] + (
            (self.meshBox["east"] - self.meshBox["west"]) / 2.0
        )
        midy = self.meshBox["south"] + (
            (self.meshBox["north"] - self.meshBox["south"]) / 2.0
        )

        # convert midpoint to lat/long
        magn_proj = int(self.magn_proj_out.split(":")[1])

        proj = Transformer.from_crs(magn_proj, 4326, always_xy=True)
        x, y = (midx, midy)
        long, lat = proj.transform(x, y)

        # calculate IGRF compnents and  convert to Inc, Dec, Int
        Be, Bn, Bu = igrf(
            long, lat, self.magn_SurveyHeight, date
        )  # returns east, north, up
        (
            self.forward_magneticField_inclination,
            self.forward_magneticField_declination,
        ) = get_inclination_declination(Be, Bn, Bu, degrees=True)
        self.forward_magneticField_intensity = np.sqrt(Be**2 + Bn**2 + Bu**2)

        # update widgets
        self.dlg.doubleSpinBox_mag_dec.setValue(
            self.forward_magneticField_declination.item()
        )
        self.dlg.doubleSpinBox_mag_inc.setValue(
            self.forward_magneticField_inclination.item()
        )
        self.dlg.doubleSpinBox_mag_int.setValue(
            self.forward_magneticField_intensity.item()
        )

    # enable gui widgets after data loaded
    def update_widgets(self):

        if self.global_experimentType == 1 or self.global_experimentType == 3:

            self.xcol_grav = self.dlg.comboBox_grav_field_x.currentText()
            self.ycol_grav = self.dlg.comboBox_grav_field_y.currentText()
            self.datacol_grav = self.dlg.comboBox_grav_field_data.currentText()

            # enable GroupBox 2
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.lineEdit_dtm_path.setEnabled(False)
            self.dlg.pushButton_select_dtm_path.setEnabled(True)

            # enable GroupBox 3
            self.dlg.groupBox_3.setEnabled(True)
            self.dlg.lineEdit_output_directory_path.setEnabled(True)
            self.dlg.lineEdit_output_directory_path_select.setEnabled(True)
            self.dlg.lineEdit_ROI_path_select.setEnabled(True)
        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.xcol_magn = self.dlg.comboBox_magn_field_x.currentText()
            self.ycol_magn = self.dlg.comboBox_magn_field_y.currentText()
            self.datacol_magn = self.dlg.comboBox_magn_field_data.currentText()

            # enable GroupBox 2
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_10.setEnabled(True)
            self.dlg.lineEdit_dtm_path.setEnabled(True)
            self.dlg.pushButton_select_dtm_path.setEnabled(True)

            # enable GroupBox 3
            self.dlg.groupBox_3.setEnabled(True)
            self.dlg.lineEdit_output_directory_path.setEnabled(True)
            self.dlg.lineEdit_output_directory_path_select.setEnabled(True)
            self.dlg.lineEdit_ROI_path_select.setEnabled(True)

        self.dlg.doubleSpinBox_coreDepth.setEnabled(True)
        self.dlg.doubleSpinBox_fullDepth.setEnabled(True)
        self.dlg.mQgsDoubleSpinBox_compression_ratio.setEnabled(True)

    # process load grav point data and display as layer
    def load_csv_vector_grav(self, data_file_path, xcol_grav, ycol_grav, datacol_grav):

        fileInfo = QFileInfo(data_file_path)
        baseName = fileInfo.baseName()

        layer = QgsVectorLayer(
            "file:///"
            + data_file_path
            + "?crs={}&xField={}&yField={}".format(
                self.grav_proj_in, xcol_grav, ycol_grav
            ),
            baseName,
            "delimitedtext",
        )
        suffix = "_grav"
        target_crs = self.grav_proj_out
        if layer.isValid():
            parameter = {
                "INPUT": layer,
                "TARGET_CRS": target_crs,
                "OUTPUT": "memory:{}_Reprojected".format(baseName + suffix),
            }
            result = processing.run("native:reprojectlayer", parameter)["OUTPUT"]
            crs = layer.crs()
            crs.createFromId(int(target_crs.split(":")[1]))
            result.setCrs(crs)
            result.renderer().symbol().setSize(0.25)
            QgsProject.instance().addMapLayer(result)
            self.colour_points(result, datacol_grav, "Spectral", True)
            result.triggerRepaint()
            self.nData = result.featureCount()
            # Use the coordinates of the bounding box as limits of mesh (without padding)
            self.data_extents(result)

        else:
            self.iface.messageBar().pushMessage(
                "Invalid grav layer", level=Qgis.Warning, duration=15
            )

    # process load magn point data and display as layer
    def load_csv_vector_magn(self, data_file_path, xcol, ycol, datacol_magn):

        fileInfo = QFileInfo(self.filename_magn)
        baseName = fileInfo.baseName()
        layer = QgsVectorLayer(
            "file:///"
            + data_file_path
            + "?crs={}&xField={}&yField={}".format(self.magn_proj_in, xcol, ycol),
            baseName,
            "delimitedtext",
        )
        suffix = "_magn"
        target_crs = self.magn_proj_out
        if layer.isValid():
            parameter = {
                "INPUT": layer,
                "TARGET_CRS": target_crs,
                "OUTPUT": "memory:{}_Reprojected".format(baseName + suffix),
            }
            result = processing.run("native:reprojectlayer", parameter)["OUTPUT"]
            crs = layer.crs()
            crs.createFromId(int(target_crs.split(":")[1]))
            result.setCrs(crs)
            result.renderer().symbol().setSize(0.25)
            QgsProject.instance().addMapLayer(result)
            self.colour_points(result, datacol_magn, "Spectral", True)
            result.triggerRepaint()
            self.nData = result.featureCount()

            # Use the coordinates of the bounding box as limits of mesh (without padding)
            self.data_extents(result)

        else:
            self.iface.messageBar().pushMessage(
                "Invalid magn layer", level=Qgis.Warning, duration=15
            )

    # calc data extends and update widget
    def data_extents(self, layer):
        extent = layer.extent()  # Get the extent (bounding box) of the layer

        # Use the coordinates of the bounding box as limits of mesh (without padding)

        self.dlg.mQgsSpinBox_mesh_south.setValue(int(extent.yMinimum()))
        self.dlg.mQgsSpinBox_mesh_north.setValue(int(extent.yMaximum()))
        self.dlg.mQgsSpinBox_mesh_west.setValue(int(extent.xMinimum()))
        self.dlg.mQgsSpinBox_mesh_east.setValue(int(extent.xMaximum()))

        self.meshBox = {
            "south": int(extent.yMinimum()),
            "west": int(extent.xMinimum()),
            "north": int(extent.yMaximum()),
            "east": int(extent.xMaximum()),
        }

    # rearrange layers so points ontop of rasters
    def rearrange(self):
        from collections import OrderedDict

        root = QgsProject.instance().layerTreeRoot()
        LayerNamesEnumDict = lambda listCh: {
            listCh[q[0]].name() + str(q[0]): q[1] for q in enumerate(listCh)
        }

        mLNED = LayerNamesEnumDict(root.children())
        mLNEDkeys = OrderedDict(
            sorted(LayerNamesEnumDict(root.children()).items())
        ).keys()

        mLNEDsorted = [mLNED[k].clone() for k in mLNEDkeys]
        root.insertChildNodes(0, mLNEDsorted)
        for n in mLNED.values():
            root.removeChildNode(n)

    # load top layer of mesh and display as points layer
    def load_mesh_vector(self):
        df = pd.read_csv(
            self.global_outputFolderPath + "/model_grid.txt",
            sep=" ",
            skiprows=1,
            header=None,
            nrows=self.data2tomofast.nx * self.data2tomofast.ny,
        )
        df[0] = (df[0] + df[1]) / 2.0
        df[2] = (df[2] + df[3]) / 2.0
        df = df.drop(axis=1, columns=[1, 3, 4, 5, 6, 7, 8, 9])

        temp = QgsVectorLayer("Point", "model_grid", "memory")
        temp_data = temp.dataProvider()
        # Start of the edition
        temp.startEditing()

        # Creation of my fields
        for head in df:
            myField = QgsField(str(head), QVariant.Double)
            temp.addAttribute(myField)
        # Update
        temp.updateFields()

        # Addition of features
        # [1] because i don't want the indexes
        for row in df.itertuples():
            f = QgsFeature()
            f.setAttributes([row[1], row[2]])
            f.setGeometry(QgsPoint(row[1], row[2]))
            temp.addFeature(f)

        # saving changes and adding the layer
        temp.commitChanges()
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            crs = QgsCoordinateReferenceSystem(self.grav_proj_out)
        else:
            crs = QgsCoordinateReferenceSystem(self.magn_proj_out)

        temp.setCrs(crs)
        temp.renderer().symbol().setSize(0.25)

        temp.commitChanges()

        QgsProject.instance().addMapLayer(temp)
        if self.global_elevType == 2:
            self.sample_elevation()

    # extract dtm values based on mesh locaitons
    def sample_elevation(self):
        mesh = QgsProject.instance().mapLayersByName("model_grid")[0]
        dtm = QgsProject.instance().mapLayersByName("Reprojected DTM")[0]

        parameter = {
            "INPUT": mesh,
            "RASTERCOPY": dtm,
            "COLUMN_PREFIX": "elevation",
            "OUTPUT": "TEMPORARY_OUTPUT",
        }
        processing.runAndLoadResults("native:rastersampling", parameter)

        elev = QgsProject.instance().mapLayersByName("Sampled")[0]
        elev.setName("elevation_grid")
        elev.renderer().symbol().setSize(0.25)

        self.rename_dp_field(elev, "0", "x")
        self.rename_dp_field(elev, "2", "y")
        self.rename_dp_field(elev, "elevation1", "elevation")

        self.colour_points(elev, "elevation", "Greys", True)

        # Start an edit session
        elev.startEditing()

        # Get the index of the field to be modified (e.g., 'Log MS')
        field_index = elev.fields().indexOf("elevation")

        # Iterate over the features and set the negative values
        for feature in elev.getFeatures():
            original_value = feature[field_index]

            if original_value is not None:
                negative_value = -original_value

                # Update the field with the negative value
                elev.changeAttributeValue(feature.id(), field_index, negative_value)
        elev.commitChanges()

        QgsVectorFileWriter.writeAsVectorFormat(
            elev,
            self.global_outputFolderPath + "/elevation_grid.csv",
            "utf-8",
            driverName="CSV",
        )

    # rename layer field name
    def rename_dp_field(self, rlayer, oldname, newname):
        findex = rlayer.dataProvider().fieldNameIndex(oldname)
        if findex != -1:
            rlayer.dataProvider().renameAttributes({findex: newname})
            rlayer.updateFields()

    # load raster dtm and siplay
    def load_dtm(self):
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            proj_in = self.grav_proj_in
            proj_out = self.grav_proj_out
        else:
            proj_in = self.magn_proj_in
            proj_out = self.magn_proj_out

        fileInfo = QFileInfo(self.dtm_filename)
        baseName = fileInfo.baseName()
        layer = QgsRasterLayer(self.dtm_filename, baseName)

        if layer.isValid():

            parameter = {
                "INPUT": self.dtm_filename,
                "SOURCE_CRS": QgsCoordinateReferenceSystem(proj_in),
                "TARGET_CRS": QgsCoordinateReferenceSystem(proj_out),
                "RESAMPLING": 0,
                "NODATA": None,
                "TARGET_RESOLUTION": None,
                "OPTIONS": "",
                "DATA_TYPE": 0,
                "TARGET_EXTENT": None,
                "TARGET_EXTENT_CRS": None,
                "MULTITHREADING": False,
                "EXTRA": "",
                "OUTPUT": "TEMPORARY_OUTPUT",
            }

            result = processing.runAndLoadResults("gdal:warpreproject", parameter)

            temppath = result["OUTPUT"]
            gd = gdal.Open(temppath)
            self.dtm_array = gd.ReadAsArray()
            layers = QgsProject.instance().mapLayersByName("Reprojected")
            layers[0].setName("Reprojected DTM")
            self.rearrange()
        else:
            self.iface.messageBar().pushMessage(
                "invalid layer",
                "file:///" + self.dtm_filename,
                level=Qgis.Warning,
                duration=45,
            )

    # load data
    def process_data_file(self):
        if self.global_experimentType == 1:
            filename = self.dlg.lineEdit_grav_data_path.text()
            paths = os.path.split(filename)
            self.global_dataNameGrav = "".join(paths[1].split(".")[:-1])
        elif self.global_experimentType == 2:
            filename = self.dlg.lineEdit_magn_data_path.text()
            paths = os.path.split(filename)
            self.global_dataNameMagn = "".join(paths[1].split(".")[:-1])
        else:
            filename = self.dlg.lineEdit_grav_data_path.text()
            paths = os.path.split(filename)
            self.global_dataNameGrav = "".join(paths[1].split(".")[:-1])

            filename = self.dlg.lineEdit_magn_data_path.text()
            paths = os.path.split(filename)
            self.global_dataNameMagn = "".join(paths[1].split(".")[:-1])

        suffix = paths[1].split(".")[-1]

        if suffix.lower() == "csv":
            self.data = pd.read_csv(filename)

            if self.global_experimentType == 1 or self.global_experimentType == 3:
                self.dlg.comboBox_grav_field_x.addItems(self.data.columns)
                self.dlg.comboBox_grav_field_y.addItems(self.data.columns)
                self.dlg.comboBox_grav_field_y.setCurrentIndex(1)

                self.dlg.comboBox_grav_field_data.addItems(self.data.columns)
                self.dlg.comboBox_grav_field_data.setCurrentIndex(2)
                self.input_data_grav = filename

            if self.global_experimentType == 2 or self.global_experimentType == 3:
                self.dlg.comboBox_magn_field_x.addItems(self.data.columns)
                self.dlg.comboBox_magn_field_y.addItems(self.data.columns)
                self.dlg.comboBox_magn_field_y.setCurrentIndex(1)

                self.dlg.comboBox_magn_field_data.addItems(self.data.columns)
                self.dlg.comboBox_magn_field_data.setCurrentIndex(2)
                self.input_data_magn = filename

            self.global_dataType = "points"

        elif suffix.lower() == "tif" or suffix.lower() == "tiff":
            # Load the TIFF file as a QgsRasterLayer
            self.data_raster_layer = QgsRasterLayer(filename, "data")
            extent = self.data_raster_layer.extent()
            if self.global_experimentType == 1 or self.global_experimentType == 3:
                out_proj = int(
                    self.dlg.mQgsProjectionSelectionWidget_grav_out.crs()
                    .authid()
                    .split(":")[1]
                )
            else:
                out_proj = int(
                    self.dlg.mQgsProjectionSelectionWidget_magn_out.crs()
                    .authid()
                    .split(":")[1]
                )
            layer_crs = int(self.data_raster_layer.crs().authid().split(":")[1])

            proj = Transformer.from_crs(layer_crs, out_proj, always_xy=True)
            x, y = (extent.xMinimum(), extent.yMinimum())
            minx, miny = proj.transform(x, y)

            x, y = (extent.xMaximum(), extent.yMaximum())
            maxx, maxy = proj.transform(x, y)

            self.dlg.mQgsSpinBox_mesh_south.setValue(int(miny))
            self.dlg.mQgsSpinBox_mesh_north.setValue(int(maxy))
            self.dlg.mQgsSpinBox_mesh_west.setValue(int(minx))
            self.dlg.mQgsSpinBox_mesh_east.setValue(int(maxx))

            self.meshBox = {
                "south": int(miny),
                "west": int(minx),
                "north": int(maxy),
                "east": int(maxx),
            }

            # Check if the layer was loaded successfully
            if not self.data_raster_layer.isValid():
                print("Failed to load the raster layer!")
            else:
                # Add the raster layer to the QGIS project
                QgsProject.instance().addMapLayer(self.data_raster_layer)
                self.update_model_grid_size()

            self.global_dataType = "raster"

    # select directory to store intermediate and final products
    def select_ouput_directory(self):
        self.global_outputFolderPath = QFileDialog.getExistingDirectory(
            None, "Select output path for your Tomofast-x input files"
        )

        self.dlg.lineEdit_output_directory_path.setText(self.global_outputFolderPath)
        if self.global_outputFolderPath:
            if os.path.exists(self.global_outputFolderPath):
                self.output_directory = os.path.split(
                    self.dlg.lineEdit_output_directory_path.text()
                )[-1]

                self.save_outputs()
                self.iface.messageBar().pushMessage(
                    "Files saved to ",
                    self.dlg.lineEdit_output_directory_path.text(),
                    "Directory",
                    level=Qgis.Success,
                    duration=15,
                )
                self.dlg.pushButton_save_paramfile.setEnabled(True)
                self.dlg.pushButton_calc_IGRF.setEnabled(True)
                self.update_memory_size()

    # calculate mesh and add topographic info before saveing out again
    def save_outputs(self):

        self.setupMesh()

        if self.global_experimentType == 1:
            self.dlg.mQgsDoubleSpinBox_grav_weight.setValue(1.0)
            self.dlg.mQgsDoubleSpinBox_magn_weight.setValue(0.0)
        elif self.global_experimentType == 2:
            self.dlg.mQgsDoubleSpinBox_grav_weight.setValue(0.0)
            self.dlg.mQgsDoubleSpinBox_magn_weight.setValue(1.0)

        if self.global_dataType == "points":
            self.convert_point_data(self.global_dataType)
        else:
            if self.global_experimentType == 1:
                self.convert_raster_data(self.filename_grav, self.grav_proj_out, 1)
                self.convert_point_data(self.global_dataType)

            elif self.global_experimentType == 2:
                self.convert_raster_data(self.filename_magn, self.magn_proj_out, 2)
                self.convert_point_data(self.global_dataType)

            else:
                self.convert_raster_data(self.filename_grav, self.grav_proj_out, 1)
                self.convert_point_data(self.global_dataType)
                self.convert_raster_data(self.filename_magn, self.magn_proj_out, 2)
                self.convert_point_data(self.global_dataType)

        self.load_mesh_vector()
        if self.global_elevType == 2:
            mean_elevation = self.data2tomofast.add_topography(
                self.global_outputFolderPath + "/model_grid.txt",
                self.global_outputFolderPath + "/elevation_grid.csv",
            )
        else:
            mean_elevation = 0

        self.tidy_layers()

    def tidy_data(self, temp_file_path1, fileName1, dataName1):
        # Read the file manually, skipping the first line, and saving it as temporary CSV
        with open(fileName1, "r") as f:
            lines = f.readlines()[1:]  # Skip the first line

        with open(temp_file_path1, "w") as temp_file:

            temp_file.writelines(f"x y height {dataName1}\n")
            temp_file.writelines(lines)
            temp_file.flush()
            temp_file.close()

        temp_data = pd.read_csv(
            temp_file_path1,
            na_values=["", " "],
            delim_whitespace=True,  # Handles whitespace-separated data
        )
        temp_data = temp_data.dropna()
        data_len = len(temp_data)
        if self.global_experimentType == 1:
            self.forward_data_grav_nData = data_len
        else:
            self.forward_data_magn_nData = data_len

        temp_data.to_csv(temp_file_path1, sep=" ", index=False)

        with open(fileName1, "w") as temp_file:

            temp_file.writelines(f"{data_len}\n")
            temp_file.flush()
            temp_file.close()

        temp_data.to_csv(f"{fileName1}", sep=" ", header=False, index=False, mode="a")

    # close temp layers, load reprojected layers and update project crs
    def tidy_layers(self):
        # reset project CRS
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            QgsProject.instance().setCrs(
                QgsCoordinateReferenceSystem(self.grav_proj_out)
            )
        else:
            QgsProject.instance().setCrs(
                QgsCoordinateReferenceSystem(self.magn_proj_out)
            )

        # close temp layers
        if self.global_dataType == "points":
            if self.global_elevType == 1:
                layers = []
            else:
                layers = ["elevation_grid"]

        else:
            if self.global_elevType == 1:
                layers = ["Extracted Data", "data"]
            else:
                layers = ["Extracted Data", "elevation_grid", "data"]

        for layer in layers:
            layer = QgsProject.instance().mapLayersByName(layer)[0]
            if layer.isValid():
                QgsProject.instance().removeMapLayer(layer)

        if self.global_dataType != "points":
            # open reprojected data layers
            xcol = "POINT_X"
            ycol = "POINT_Y"

            if self.global_experimentType == 1:
                fileName1 = self.global_outputFolderPath + "/data_grav.csv"
                proj1 = self.grav_proj_out
                dataName1 = "grav_data"
            elif self.global_experimentType == 2:
                fileName1 = self.global_outputFolderPath + "/data_magn.csv"
                proj1 = self.magn_proj_out
                dataName1 = "magn_data"
            elif (
                self.global_experimentType == 3
            ):  # need to add NaN removable for this case
                fileName1 = self.global_outputFolderPath + "/data_grav.csv"
                proj1 = self.grav_proj_out
                dataName1 = "grav_data"
                fileName2 = self.global_outputFolderPath + "/data_magn.csv"
                dataName2 = "magn_data"

            temp_file_path1 = self.global_outputFolderPath + "/data_temp.csv"

            self.tidy_data(temp_file_path1, fileName1, dataName1)

            
            # Define the URI to load the CSV with specified geometry fields and no header
            # uri = f"file://{temp_file_path1}?type=csv&xField=x&yField=y&detectTypes=no&geomType=Point&spatialIndex=no&crs={proj1}"
            uri = f"file:///{temp_file_path1}?type=csv&delimiter=,%20&quote=&escape=&maxFields=10000&detectTypes=yes&xField=x&yField=y&spatialIndex=no&subsetIndex=no&watchFile=no&crs={proj1}"

            # Load the layer as a point layer
            layer = QgsVectorLayer(uri, dataName1, "delimitedtext")

            if layer.isValid():
                QgsProject.instance().addMapLayer(layer)
                layer.renderer().symbol().setSize(0.125)
                self.colour_points(layer, dataName1, "Rocket", False)
                layer.triggerRepaint()

            else:
                print("Failed to load layer.")

            if self.global_experimentType == 3:
                self.tidy_data(temp_file_path1, fileName2, dataName2)

                uri = f"file:///{temp_file_path1}?type=csv&delimiter=,%20&quote=&xField=x&yField=y&detectTypes=no&geomType=Point&spatialIndex=no&crs={proj1}"

                layer = QgsVectorLayer(uri, dataName2, "delimitedtext")

                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    
                    # Check if the renderer exists and is of correct type before modifying
                    renderer = layer.renderer()
                    if renderer and hasattr(renderer, 'symbol') and callable(getattr(renderer, 'symbol', None)):
                        # For single symbol renderer
                        symbol = renderer.symbol()
                        if symbol:
                            symbol.setSize(0.125)
                    else:
                        # Either create a new renderer or handle different renderer types
                        # For example, creating a new single symbol renderer:
                        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'size': '0.125'})
                        layer.setRenderer(QgsSingleSymbolRenderer(symbol))
                    
                    self.colour_points(layer, dataName2, "Mako", False)
                    layer.triggerRepaint()

                else:
                    print("Failed to load layer.")

        self.iface.mapCanvas().refresh()

    # get mesh parameters from gui
    def setupMesh(self):
        self.cell_x = self.dlg.mQgsSpinBox_mesh_size_x.value()
        self.cell_y = self.dlg.mQgsSpinBox_mesh_size_y.value()
        self.padding = self.dlg.mQgsSpinBox_mesh_padding.value()

        self.dz = self.dlg.mQgsSpinBox_mesh_size_z.value()

        self.data2tomofast = Data2Tomofast(None)
        self.grav_proj_in = (
            self.dlg.mQgsProjectionSelectionWidget_grav_in.crs().authid()
        )
        self.grav_proj_out = (
            self.dlg.mQgsProjectionSelectionWidget_grav_out.crs().authid()
        )
        self.magn_proj_in = (
            self.dlg.mQgsProjectionSelectionWidget_magn_in.crs().authid()
        )
        self.magn_proj_out = (
            self.dlg.mQgsProjectionSelectionWidget_magn_out.crs().authid()
        )
        self.meshBox = {
            "south": self.dlg.mQgsSpinBox_mesh_south.value(),
            "west": self.dlg.mQgsSpinBox_mesh_west.value(),
            "north": self.dlg.mQgsSpinBox_mesh_north.value(),
            "east": self.dlg.mQgsSpinBox_mesh_east.value(),
            "core_depth": self.dlg.doubleSpinBox_coreDepth.value(),
            "full_depth": self.dlg.doubleSpinBox_fullDepth.value(),
        }

        self.global_grav_sensor_height = (
            self.dlg.doubleSpinBox_grav_sensor_height.value()
        )
        self.global_magn_sensor_height = (
            self.dlg.doubleSpinBox_magn_sensor_height.value()
        )

    # convert raster data into points based on mesh locations
    def convert_raster_data(self, filename, proj_out, dataType):

        # define  and update raster parameters
        if dataType == 1:
            self.datacol_grav = "data"
            self.filename_grav = self.global_outputFolderPath + "/data_grav.csv"
            reprojDataName = "/reproj_data_grav.tif"
            reprojPoints = "/reproj_data_grav.csv"
        else:
            self.datacol_magn = "data"
            self.filename_magn = self.global_outputFolderPath + "data_magn.csv"
            reprojDataName = "/reproj_data_magn.tif"
            reprojPoints = "/reproj_data_magn.csv"

        self.setupMesh()

        meshBoxOffset = {
            "south": int(self.meshBox["south"]),
            "west": int(self.meshBox["west"]),
            "north": int(self.meshBox["north"]),
            "east": int(self.meshBox["east"]),
            "core_depth": self.dlg.doubleSpinBox_coreDepth.value(),
            "full_depth": self.dlg.doubleSpinBox_fullDepth.value(),
        }

        # write out mesh
        self.data2tomofast.write_model_grid(
            self.padding,
            self.cell_x,
            self.cell_y,
            self.dz,
            meshBoxOffset,
            self.global_outputFolderPath,
        )

        # read in top layer of mesh
        df = pd.read_csv(
            self.global_outputFolderPath + "/model_grid.txt",
            sep=" ",
            skiprows=1,
            header=None,
            nrows=self.data2tomofast.nx * self.data2tomofast.ny,
            names=["x1", "x2", "y1", "y2", "z1", "z2,", "value", "i", "j", "k"],
        )

        # Create an empty memory layer (point geometry type, with a CRS, e.g., EPSG:4326)

        mesh_layer = QgsVectorLayer(f"Point", "Extracted Data", "memory")

        new_crs = QgsCoordinateReferenceSystem(proj_out)
        mesh_layer.setCrs(new_crs)

        # Get the data provider for the layer
        provider = mesh_layer.dataProvider()

        # Define the fields (attributes) for the layer
        fields = QgsFields()
        fields.append(QgsField("id", QVariant.Int))

        # Add the fields to the provider
        provider.addAttributes(fields)
        mesh_layer.updateFields()

        # Loop over the DataFrame rows to create features and add them to the layer
        for idx, row in df.iterrows():
            # Create a new feature
            feature = QgsFeature()

            # Set the geometry (Point) for the feature
            x = row["x1"] - ((row["x1"] - row["x2"]) / 2.0)
            y = row["y1"] - ((row["y1"] - row["y2"]) / 2.0)
            point = QgsPointXY(x, y)

            feature.setGeometry(QgsGeometry.fromPointXY(point))

            # Add the feature to the layer
            provider.addFeature(feature)

        # Update the layer's extent
        mesh_layer.updateExtents()

        # Add the layer to the QGIS project
        QgsProject.instance().addMapLayer(mesh_layer)

        data_layer = QgsProject.instance().mapLayersByName("data")[0]

        # reproject raster data
        parameter = {
            "INPUT": filename,
            "SOURCE_CRS": data_layer.crs(),
            "TARGET_CRS": QgsCoordinateReferenceSystem(proj_out),
            "RESAMPLING": 0,
            "NODATA": None,
            "TARGET_RESOLUTION": None,
            "OPTIONS": "",
            "DATA_TYPE": 0,
            "TARGET_EXTENT": None,
            "TARGET_EXTENT_CRS": None,
            "MULTITHREADING": False,
            "EXTRA": "",
            "OUTPUT": self.global_outputFolderPath + reprojDataName,
        }

        # Run the processing algorithm
        processing.run("gdal:warpreproject", parameter)

        # sample raster data based on mesh locations
        parameter = {
            "INPUT": mesh_layer,
            "RASTERCOPY": self.global_outputFolderPath + reprojDataName,
            "COLUMN_PREFIX": "data",
            "OUTPUT": "memory:",
        }
        print("parameter",parameter)
        # Get the layer ID from runAndLoadResults
        layer_id = processing.runAndLoadResults("native:rastersampling", parameter)["OUTPUT"]

        # Get the actual layer object from the ID
        new_data_layer = QgsProject.instance().mapLayer(layer_id)

        # convert layer to dataframe
        data = []
        # Extract the fields (attributes) names
        fields = [field.name() for field in new_data_layer.fields()]
        fields.append("POINT_X")
        fields.append("POINT_Y")
        # Loop through features in the layer
        for feature in new_data_layer.getFeatures():
            # Extract attribute values
            attributes = feature.attributes()
            geometry = feature.geometry()
            point = geometry.asPoint()
            attributes.append(point.x())
            attributes.append(point.y())
            # Add attributes and geometry to the data list
            data.append(attributes)

        # Create a pandas DataFrame
        data_df = pd.DataFrame(data, columns=fields)
        
        # Only drop columns if they exist in the dataframe
        if "fid" in data_df.columns:
            data_df = data_df.drop(columns=["fid"])
        if "id" in data_df.columns:
            data_df = data_df.drop(columns=["id"])

        new_column_order = ["POINT_X", "POINT_Y", "data1"]
        data_df = data_df[new_column_order]
        QgsProject.instance().removeMapLayer(new_data_layer)

        # save out extracted data as same format as points data
        data_df.to_csv(self.global_outputFolderPath + reprojPoints, index=False)

    # convert point data to tomofast format
    def convert_point_data(self, dataFormat):

        # add elevation to data
        if self.global_experimentType == 1:  # grav
            if dataFormat == "points":
                self.data2tomofast.read_data(
                    self.filename_grav,
                    self.ycol_grav,
                    self.xcol_grav,
                    self.datacol_grav,
                    self.grav_proj_in,
                    self.grav_proj_out,
                )
            else:
                self.data2tomofast.read_data(
                    self.global_outputFolderPath + "/reproj_data_grav.csv",
                    "POINT_Y",
                    "POINT_X",
                    "data1",
                    self.grav_proj_out,
                    self.grav_proj_out,
                )
                self.datacol_grav = "data1"
            if self.global_elevType == 1:  # const elev

                self.data2tomofast.add_elevation(
                    self.global_grav_sensor_height, self.global_elevType, 0
                )
            else:  # dtm
                self.add_dtm(1)
                self.data2tomofast.add_elevation(
                    self.global_grav_sensor_height, self.global_elevType, self.data_df
                )
            self.data2tomofast.write_data_tomofast(
                self.datacol_grav, self.global_outputFolderPath, 1
            )

        elif self.global_experimentType == 2:  # mag
            if dataFormat == "points":
                self.data2tomofast.read_data(
                    self.filename_magn,
                    self.ycol_magn,
                    self.xcol_magn,
                    self.datacol_magn,
                    self.magn_proj_in,
                    self.magn_proj_out,
                )
            else:
                self.data2tomofast.read_data(
                    self.global_outputFolderPath + "/reproj_data_magn.csv",
                    "POINT_Y",
                    "POINT_X",
                    "data1",
                    self.magn_proj_out,
                    self.magn_proj_out,
                )
                self.datacol_magn = "data1"
            if self.global_elevType == 1:
                self.data2tomofast.add_elevation(
                    self.global_magn_sensor_height, self.global_elevType, 0
                )
            else:
                self.add_dtm(2)
                self.data2tomofast.add_elevation(
                    self.global_magn_sensor_height, self.global_elevType, self.data_df
                )
            self.data2tomofast.write_data_tomofast(
                self.datacol_magn, self.global_outputFolderPath, 2
            )
        else:  # grav and mag
            if dataFormat == "points":
                self.data2tomofast.read_data(
                    self.filename_grav,
                    self.ycol_grav,
                    self.xcol_grav,
                    self.datacol_grav,
                    self.grav_proj_in,
                    self.grav_proj_out,
                )
            else:
                self.data2tomofast.read_data(
                    self.global_outputFolderPath + "/reproj_data_grav.csv",
                    "POINT_Y",
                    "POINT_X",
                    "data1",
                    self.grav_proj_out,
                    self.grav_proj_out,
                )
                self.datacol_grav = "data1"
            if self.global_elevType == 1:  # const elev
                self.data2tomofast.add_elevation(
                    self.global_grav_sensor_height, self.global_elevType, 0
                )
            else:  # dtm
                self.add_dtm(1)
                self.data2tomofast.add_elevation(
                    self.global_grav_sensor_height, self.global_elevType, self.data_df
                )
            self.data2tomofast.write_data_tomofast(
                self.datacol_grav, self.global_outputFolderPath, 1
            )

            if dataFormat == "points":
                self.data2tomofast.read_data(
                    self.filename_magn,
                    self.ycol_magn,
                    self.xcol_magn,
                    self.datacol_magn,
                    self.magn_proj_in,
                    self.magn_proj_out,
                )
            else:
                self.data2tomofast.read_data(
                    self.global_outputFolderPath + "/reproj_data_magn.csv",
                    "POINT_Y",
                    "POINT_X",
                    "data1",
                    self.magn_proj_out,
                    self.magn_proj_out,
                )
                self.datacol_magn = "data1"
            if self.global_elevType == 1:
                self.data2tomofast.add_elevation(
                    self.global_magn_sensor_height, self.global_elevType, 0
                )
            else:
                self.add_dtm(1)
                self.data2tomofast.add_elevation(
                    self.global_magn_sensor_height, self.global_elevType, self.data_df
                )
            self.data2tomofast.write_data_tomofast(
                self.datacol_magn, self.global_outputFolderPath, 2
            )

        if dataFormat == "points":
            self.data2tomofast.write_model_grid(
            self.padding,
            self.cell_x,
            self.cell_y,
            self.dz,
            self.meshBox,
            self.global_outputFolderPath,
            )

        self.dlg.nx_label.setText(str(self.data2tomofast.nx))
        self.dlg.ny_label.setText(str(self.data2tomofast.ny))
        self.dlg.nz_label.setText(str(self.data2tomofast.nz))

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.forward_data_grav_nData = self.data2tomofast.nData
        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.forward_data_magn_nData = self.data2tomofast.nData

    def update_model_grid_size(self):
        self.setupMesh()

        nx = int(
            (self.meshBox["east"] - self.meshBox["west"] + (2 * self.padding))
            / self.cell_x
        )
        ny = int(
            (self.meshBox["north"] - self.meshBox["south"] + (2 * self.padding))
            / self.cell_y
        )

        ncore = int(
            float(self.dlg.doubleSpinBox_coreDepth.value())
            / float(self.dlg.mQgsSpinBox_mesh_size_z.value())
        )
        npad = int(
            np.log(
                float(
                    self.dlg.doubleSpinBox_fullDepth.value()
                    - float(self.dlg.doubleSpinBox_coreDepth.value())
                )
                / (float(self.dlg.mQgsSpinBox_mesh_size_z.value()))
            )
            / np.log(1.15)
        )
        nz = ncore + npad

        self.dlg.nx_label.setText(str(nx))
        self.dlg.ny_label.setText(str(ny))
        self.dlg.nz_label.setText(str(nz))
        self.update_memory_size()

    def update_memory_size(self):
        self.setupMesh()
        if self.dlg.checkBox_use_compression.isChecked():
            compression = self.dlg.mQgsDoubleSpinBox_compression_ratio.value()
        else:
            compression = 1.0

        nx = int(
            (self.meshBox["east"] - self.meshBox["west"] + (2 * self.padding))
            / self.cell_x
        )
        ny = int(
            (self.meshBox["north"] - self.meshBox["south"] + (2 * self.padding))
            / self.cell_y
        )
        ncore = int(
            float(self.dlg.doubleSpinBox_coreDepth.value())
            / float(self.dlg.mQgsSpinBox_mesh_size_z.value())
        )
        npad = int(
            np.log(
                float(
                    self.dlg.doubleSpinBox_fullDepth.value()
                    - float(self.dlg.doubleSpinBox_coreDepth.value())
                )
                / (float(self.dlg.mQgsSpinBox_mesh_size_z.value()))
            )
            / np.log(1.15)
        )
        nz = ncore + npad

        if not self.suffix_known:
            # Determine which input path to use based on experiment type
            if self.global_experimentType in {1, 3}:
                data_path = self.dlg.lineEdit_grav_data_path.text()
            else:
                data_path = self.dlg.lineEdit_magn_data_path.text()

            # Extract suffix and store it
            suffix = data_path.split(".")[-1].lower()
            self.suffix_known = suffix
            if self.suffix_known != "csv":
                self.nData = nx * ny

        if self.global_experimentType == 1:
            memory = 8 * compression * nx * ny * nz * self.nData
        elif self.global_experimentType == 2:
            memory = 8 * compression * nx * ny * nz * self.nData
        else:
            memory = 8 * compression * nx * ny * nz * self.nData * 2

        memory = round(memory / (1024 * 1024 * 1024), 3)
        self.dlg.memory_label.setText(str(memory))

    def reproj_raster(self, rasterInPath, targetCrs, dataType):
        parameter = {
            "INPUT": rasterInPath,
            "TARGET_CRS": targetCrs,
            "OUTPUT": "memory:{}_Reprojected".format(dataType),
        }
        result = processing.run("native:reprojectlayer", parameter)["OUTPUT"]

    # add raster dtm or gridded flight height to data file
    def add_dtm(self, dataType):
        # get dtm layer
        reprojDTM = QgsProject.instance().mapLayersByName("Reprojected DTM")[0]

        if dataType == 1:
            dataFileName = "/data_grav.csv"
            proj_out = self.grav_proj_out
            proj_in = self.grav_proj_in
            data_column = self.datacol_grav
            reprojDataLayerName = "reproj_grav_data"
            if self.global_dataType == "points":
                reprojFileName = self.global_dataNameGrav + "_grav_Reprojected"
            else:
                reprojFileName = "/reproj_data_grav.csv"

        else:
            dataFileName = "/data_magn.csv"
            proj_out = self.magn_proj_out
            proj_in = self.magn_proj_in
            data_column = self.datacol_magn
            reprojDataLayerName = "reproj_magn_data"
            if self.global_dataType == "points":
                reprojFileName = self.global_dataNameMagn + "_magn_Reprojected"
            else:
                reprojFileName = "/reproj_data_magn.csv"

        if self.global_dataType == "points":
            df = pd.DataFrame(self.data2tomofast.df)
            column_list = {
                df.columns[0]: "x",
                df.columns[1]: "y",
                # df.columns[2]: "z",
                # df.columns[2]: data_column,
            }
            df = df.rename(columns=column_list)
            layer = QgsVectorLayer("Point?crs=" + proj_in, "My Points Layer", "memory")

            # Get the data provider for the layer
            provider = layer.dataProvider()

            # Define the fields (attributes) for the layer
            fields = QgsFields()
            fields.append(QgsField("id", QVariant.Int))
            fields.append(QgsField("POINT_X", QVariant.Double))
            fields.append(QgsField("POINT_Y", QVariant.Double))
            fields.append(QgsField(data_column, QVariant.Double))

            # Add the fields to the provider
            provider.addAttributes(fields)
            layer.updateFields()

            # Loop over the DataFrame rows to create features
            for idx, row in df.iterrows():
                # Create a new feature
                feature = QgsFeature()
                # Set the geometry (Point) for the feature
                point = QgsPointXY(row["x"], row["y"])
                feature.setGeometry(QgsGeometry.fromPointXY(point))

                # Set the attributes (fields) for the feature
                feature.setAttributes([idx, row["x"], row["y"], row[data_column]])

                # Add the feature to the layer
                provider.addFeature(feature)

                # Update layer's extent
                layer.updateExtents()

            layer.commitChanges()
        else:
            # load data layer
            layer = QgsVectorLayer(
                "file:///"
                + self.global_outputFolderPath
                + reprojFileName
                + "?crs={}&xField={}&yField={}".format(proj_out, "POINT_X", "POINT_Y"),
                reprojDataLayerName,
                "delimitedtext",
            )

        # sample dtm layer using grav points
        parameter = {
            "INPUT": layer,
            "RASTERCOPY": reprojDTM,
            "COLUMN_PREFIX": "elevation",
            "OUTPUT": "memory",
        }
        processing.runAndLoadResults("native:rastersampling", parameter)["OUTPUT"]

        new_data_layer = QgsProject.instance().mapLayersByName("memory")[0]

        # convert to pandas
        data = []
        # Extract the fields (attributes) names
        fields = [field.name() for field in new_data_layer.fields()]
        # Loop through features in the layer
        for feature in new_data_layer.getFeatures():
            # Extract attribute values
            attributes = feature.attributes()

            # Add attributes and geometry to the data list
            data.append(attributes)

        # Create a pandas DataFrame
        data_df = pd.DataFrame(data, columns=fields)
        # data_df.to_csv(self.global_outputFolderPath + "/data_elev.csv", index=False)

        if self.global_dataType == "points":
            column_list = {
                data_df.columns[4]: "data1",
                "elevation1": "POINT_Z",
            }
        else:
            column_list = {
                "elevation1": "POINT_Z",
            }

        data_df = data_df.rename(columns=column_list)
        data_df = data_df.drop(columns=["fid"])

        new_column_order = ["POINT_X", "POINT_Y", "POINT_Z", "data1"]
        data_df = data_df[new_column_order]

        data_df.to_csv(self.global_outputFolderPath + dataFileName, index=False)

        self.data_df = data_df.copy(deep=True)
        QgsProject.instance().removeMapLayer(new_data_layer)

    # write out section titles
    def spacer(self, title):
        self.f_params.write("\n")
        self.f_params.write(
            "===================================================================================\n"
        )
        self.f_params.write(title + "\n")
        self.f_params.write(
            "===================================================================================\n"
        )

    # write out parameter file
    def save_parameter_file(self):
        self.parse_parameters()
        self.dlg.lineEdit_2_parfilePath.setText(
            self.global_outputFolderPath + "/paramfile.txt"
        )
        self.paramfile_Path = self.global_outputFolderPath + "/paramfile.txt"
        self.f_params = open(self.global_outputFolderPath + "/paramfile.txt", "w")

        self.spacer("GLOBAL")
        self.f_params.write(
            "global.outputFolderPath             = {}\n".format(
                self.global_outputFolderPath + "/OUTPUT"
            )
        )
        if not self.global_description:
            self.global_description = "Inversion Experiment"
        self.f_params.write(
            "global.description                  = {}\n".format(self.global_description)
        )
        self.f_params.write(
            "#global.experimentType               = {}\n".format(
                self.global_experimentType
            )
        )

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "global.grav.dataUnitsMultiplier     = {}\n".format(
                    "1.d" + str(int(self.global_grav_dataUnitsMultiplier))
                )
            )
            self.f_params.write(
                "global.grav.modelUnitsMultiplier    = {}\n".format(
                    self.global_grav_modelUnitsMultiplier
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "global.magn.dataUnitsMultiplier     = {}\n".format(
                    "1.d" + str(int(self.global_magn_dataUnitsMultiplier))
                )
            )
            self.f_params.write(
                "global.magn.modelUnitsMultiplier    = {}\n".format(
                    self.global_magn_modelUnitsMultiplier
                )
            )

        self.spacer("ELEVATION parameters")
        self.f_params.write(
            "#global.elevType                     = {}\n".format(self.global_elevType)
        )

        if self.global_experimentType == 1 or self.global_experimentType == 3:

            self.f_params.write(
                "#global.grav.sensor_height                 = {}\n".format(
                    self.global_grav_sensor_height  # .item()
                )
            )
        if self.global_experimentType == 2 or self.global_experimentType == 3:

            self.f_params.write(
                "#global.magn.sensor_height                 = {}\n".format(
                    self.global_magn_sensor_height  # .item()
                )
            )

        self.spacer("MODEL GRID parameters")

        # nx ny nz
        self.f_params.write(
            "modelGrid.size                      = {} {} {}\n".format(
                self.modelGrid_size[0], self.modelGrid_size[1], self.modelGrid_size[2]
            )
        )
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "modelGrid.grav.file                 = {}\n".format(
                    self.global_outputFolderPath + "/model_grid.txt"
                )
            )
        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "modelGrid.magn.file                 = {}\n".format(
                    self.global_outputFolderPath + "/model_grid.txt"
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.spacer("MAGNETIC FIELD constants")

            self.f_params.write(
                "forward.magneticField.inclination                 = {}\n".format(
                    self.forward_magneticField_inclination  # .item()
                )
            )
            self.f_params.write(
                "forward.magneticField.declination                 = {}\n".format(
                    self.forward_magneticField_declination  # .item()
                )
            )
            self.f_params.write(
                "forward.magneticField.intensity_nT                = {}\n".format(
                    self.forward_magneticField_intensity  # .item()
                )
            )

        # if(self.global_experimentType==2 or self.global_experimentType==3):
        #    self.f_params.write("modelGrid.magn.file                 = {}\n".format(self.output_directory+"/model_magn_grid.txt"))

        self.spacer("DATA parameters")

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "forward.data.grav.nData             = {}\n".format(
                    self.forward_data_grav_nData
                )
            )
            self.f_params.write(
                "forward.data.grav.dataGridFile      = {}\n".format(
                    self.global_outputFolderPath + "/data_grav.csv"
                )
            )
            self.f_params.write(
                "forward.data.grav.dataValuesFile    = {}\n".format(
                    self.global_outputFolderPath + "/data_grav.csv"
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "forward.data.magn.nData             = {}\n".format(
                    self.forward_data_magn_nData
                )
            )
            if self.global_elevType == 1:
                self.f_params.write(
                    "forward.data.magn.dataGridFile      = {}\n".format(
                        self.global_outputFolderPath + "/data_magn.csv"
                    )
                )
                self.f_params.write(
                    "forward.data.magn.dataValuesFile    = {}\n".format(
                        self.global_outputFolderPath + "/data_magn.csv"
                    )
                )
            else:
                self.f_params.write(
                    "forward.data.magn.dataGridFile      = {}\n".format(
                        self.global_outputFolderPath + "/data_magn_topo.csv"
                    )
                )
                self.f_params.write(
                    "forward.data.magn.dataValuesFile    = {}\n".format(
                        self.global_outputFolderPath + "/data_magn_topo.csv"
                    )
                )

        self.spacer("DEPTH WEIGHTING")

        self.f_params.write(
            "forward.depthWeighting.type         = {}\n".format(
                self.forward_depthWeighting_type
            )
        )
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "forward.depthWeighting.grav.power   = {}\n".format(
                    self.forward_depthWeighting_grav_power
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "forward.depthWeighting.magn.power   = {}\n".format(
                    self.forward_depthWeighting_magn_power
                )
            )

        self.spacer("SENSITIVITY KERNEL")

        self.f_params.write(
            "sensit.readFromFiles                = {}\n".format(
                self.sensit_readFromFiles
            )
        )
        self.f_params.write(
            "sensit.folderPath                   = {}\n".format(
                self.global_outputFolderPath + "/OUTPUT/SENSIT/"
            )
        )

        self.spacer("MATRIX COMPRESSION")

        # 0-none, 1-wavelet compression.
        self.f_params.write(
            "forward.matrixCompression.type      = {}\n".format(
                self.forward_matrixCompression_type
            )
        )
        self.f_params.write(
            "forward.matrixCompression.rate      = {}\n".format(
                self.forward_matrixCompression_rate
            )
        )

        self.spacer("INVERSION parameters")

        self.f_params.write(
            "inversion.nMajorIterations          = {}\n".format(
                self.inversion_nMajorIterations
            )
        )
        self.f_params.write(
            "inversion.nMinorIterations          = {}\n".format(
                self.inversion_nMinorIterations
            )
        )
        self.f_params.write(
            "inversion.writeModelEveryNiter      = {}\n".format(
                self.inversion_writeModelEveryNiter
            )
        )

        self.spacer("MODEL DAMPING (m - m_prior)")
        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "inversion.modelDamping.grav.weight  = {}\n".format(
                    self.inversion_modelDamping_grav_weight
                )
            )
            self.f_params.write(
                "inversion.modelDamping.normPower    = {}\n".format(
                    self.inversion_modelDamping_grav_normPower
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "inversion.modelDamping.magn.weight  = {}\n".format(
                    self.inversion_modelDamping_magn_weight
                )
            )
            self.f_params.write(
                "inversion.modelDamping.normPower    = {}\n".format(
                    self.inversion_modelDamping_magn_normPower
                )
            )

        self.spacer("JOINT INVERSION parameters")

        self.f_params.write(
            "inversion.joint.grav.problemWeight  = {}\n".format(
                self.inversion_joint_grav_problemWeight
            )
        )
        self.f_params.write(
            "inversion.joint.magn.problemWeight  = {}\n".format(
                self.inversion_joint_magn_problemWeight
            )
        )

        self.spacer("ADMM constraints")

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "inversion.admm.enableADMM           = {}\n".format(
                    self.inversion_admm_grav_enableADMM
                )
            )
            self.f_params.write(
                "inversion.admm.nLithologies         = {}\n".format(
                    self.inversion_admm_grav_nLithologies
                )
            )
            if self.inversion_admm_grav_bounds == "":
                self.f_params.write(
                    "inversion.admm.grav.bounds          = {}\n".format("-1d-10 1d10")
                )
            else:
                self.f_params.write(
                    "inversion.admm.grav.bounds          = {}\n".format(
                        self.inversion_admm_grav_bounds
                    )
                )
            self.f_params.write(
                "inversion.admm.grav.weight          = {}\n".format(
                    self.inversion_admm_grav_weight
                )
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "inversion.admm.enableADMM           = {}\n".format(
                    self.inversion_admm_magn_enableADMM
                )
            )
            self.f_params.write(
                "inversion.admm.nLithologies         = {}\n".format(
                    self.inversion_admm_magn_nLithologies
                )
            )
            if self.inversion_admm_magn_bounds == "":
                self.f_params.write(
                    "inversion.admm.magn.bounds          = {}\n".format("-1d-10 1d10")
                )
            else:
                self.f_params.write(
                    "inversion.admm.magn.bounds          = {}\n".format(
                        self.inversion_admm_magn_bounds
                    )
                )
            self.f_params.write(
                "inversion.admm.magn.weight          = {}\n".format(
                    self.inversion_admm_magn_weight
                )
            )

        self.spacer("MESH")

        self.f_params.write(
            "#mesh.cellx                          = {}\n".format(self.cell_x)
        )
        self.f_params.write(
            "#mesh.celly                          = {}\n".format(self.cell_y)
        )
        self.f_params.write(
            "#mesh.cellz                          = {}\n".format(self.dz)
        )
        self.f_params.write(
            "#mesh.padding                        = {}\n".format(self.padding)
        )
        self.f_params.write(
            "#mesh.z.coreDepth                       = {}\n".format(self.z_coreDepth)
        )
        self.f_params.write(
            "#mesh.z.fullDepth                  = {}\n".format(self.z_fullDepth)
        )

        self.spacer("ANOMALIES")

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.f_params.write(
                "#anomalies.grav.data.file            = {}\n".format(self.filename_grav)
            )
            self.f_params.write(
                "#anomalies.grav.proj.in              = {}\n".format(self.grav_proj_in)
            )
            self.f_params.write(
                "#anomalies.grav.proj.out             = {}\n".format(self.grav_proj_out)
            )

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.f_params.write(
                "#anomalies.magn.data_file            = {}\n".format(self.filename_magn)
            )
            self.f_params.write(
                "#anomalies.magn.proj.in              = {}\n".format(self.magn_proj_in)
            )
            self.f_params.write(
                "#anomalies.magn.proj.out             = {}\n".format(self.magn_proj_out)
            )

        self.f_params.close()
        self.iface.messageBar().pushMessage(
            "parfile.txt saved to  {}".format(self.global_outputFolderPath),
            "OK ",
            level=Qgis.Success,
            duration=45,
        )

    # display pints layer with colours
    def colour_points(self, layer, value_field, ramp_name, invert):
        # layer_name = 'Your_layer_name'
        # ramp_name = 'Spectral'
        # value_field = 'Your_field_name'
        num_classes = 20
        classification_method = QgsClassificationEqualInterval()

        # You can use any of these classification method classes:
        # QgsClassificationQuantile()
        # QgsClassificationEqualInterval()
        # QgsClassificationJenks()
        # QgsClassificationPrettyBreaks()
        # QgsClassificationLogarithmic()
        # QgsClassificationStandardDeviation()

        # layer = QgsProject().instance().mapLayersByName(layer_name)[0]

        # change format settings as necessary
        format = QgsRendererRangeLabelFormat()
        format.setFormat("%1 - %2")
        format.setPrecision(2)
        format.setTrimTrailingZeroes(True)

        default_style = QgsStyle().defaultStyle()
        color_ramp = default_style.colorRamp(ramp_name)
        if invert:
            color_ramp.invert()
        renderer = QgsGraduatedSymbolRenderer()
        renderer.setClassAttribute(value_field)
        renderer.setClassificationMethod(classification_method)
        renderer.setLabelFormat(format)
        renderer.updateClasses(layer, num_classes)
        renderer.updateColorRamp(color_ramp)

        layer.setRenderer(renderer)
        layer.triggerRepaint()

    # load data from GUI widgets to variables
    def parse_parameters(self):

        if self.dlg.checkBox_grav_depth_weighting.isChecked():
            self.forward_depthWeighting_type = 2
        else:
            self.forward_depthWeighting_type = 1
        self.global_outputFolderPath = self.dlg.lineEdit_output_directory_path.text()
        self.global_description = self.dlg.textEdit_experiment_description.toPlainText()

        self.modelGrid_size = [
            int(self.dlg.nx_label.text()),
            int(self.dlg.ny_label.text()),
            int(self.dlg.nz_label.text()),
        ]
        self.modelGrid_grav_file = self.global_outputFolderPath + "/model_grav_grid.txt"
        self.modelGrid_magn_file = self.global_outputFolderPath + "/model_magn_grid.txt"

        self.forward_data_grav_dataGridFile = (
            self.global_outputFolderPath + "/data_grav.csv"
        )
        self.forward_data_grav_dataValuesFile = (
            self.global_outputFolderPath + "/grav_calc_read_data.txt"
        )
        self.forward_data_magn_dataGridFile = (
            self.global_outputFolderPath + "/data_magn.csv"
        )
        self.forward_data_magn_dataValuesFile = (
            self.global_outputFolderPath + "/magn_calc_read_data.txt"
        )

        if self.dlg.checkBox_grav_depth_weighting.isChecked():
            self.forward_depthWeighting_type = 2
        else:
            self.forward_depthWeighting_type = 1

        self.forward_depthWeighting_grav_power = (
            self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight.value()
        )
        self.forward_depthWeighting_magn_power = (
            self.dlg.mQgsDoubleSpinBox_mag_depth_weighting.value()
        )
        if self.dlg.checkBox_read_sens_matrix.isChecked():
            self.sensit_readFromFiles = 1
        else:
            self.sensit_readFromFiles = 0

        if self.dlg.checkBox_use_compression.isChecked():
            self.forward_matrixCompression_type = 1
        else:
            self.forward_matrixCompression_type = 2

        self.forward_matrixCompression_rate = (
            self.dlg.mQgsDoubleSpinBox_compression_ratio.value()
        )

        self.inversion_nMajorIterations = self.dlg.mQgsSpinBox_major_iters.value()
        self.inversion_nMinorIterations = self.dlg.mQgsSpinBox_minor_iters.value()
        self.inversion_writeModelEveryNiter = (
            self.dlg.mQgsSpinBox_model_save_iters.value()
        )
        self.inversion_minResidual = self.dlg.textEdit_min_residual.toPlainText()

        self.inversion_modelDamping_grav_weight = (
            self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight.value()
        )
        self.inversion_modelDamping_grav_normPower = (
            self.dlg.mQgsDoubleSpinBox_grav_mmodel_norm_power.value()
        )

        self.inversion_modelDamping_magn_weight = (
            self.dlg.mQgsDoubleSpinBox_magn_model_weight.value()
        )
        self.inversion_modelDamping_magn_normPower = (
            self.dlg.mQgsDoubleSpinBox_magn_model_norm_power.value()
        )

        self.inversion_joint_grav_problemWeight = (
            self.dlg.mQgsDoubleSpinBox_grav_weight.value()
        )
        self.inversion_joint_magn_problemWeight = (
            self.dlg.mQgsDoubleSpinBox_magn_weight.value()
        )

        if self.dlg.radioButton_grav_depth_based_ADMM.isChecked():
            self.inversion_grav_admm_enableADMM = 1
        else:
            self.inversion_grav_admm_enableADMM = 2
        if self.dlg.radioButton_magn_ADMM_dist_based.isChecked():
            self.inversion_mag_admm_enableADMM = 1
        else:
            self.inversion_mag_admm_enableADMM = 3

        self.inversion_admm_grav_nLithologies = (
            self.dlg.spinBox_grav_number_ADMM_litho.value()
        )  # ??
        self.inversion_admm_magn_nLithologies = (
            self.dlg.spinBox_magn_ADMM_number_litho.value()
        )  # ??
        if self.dlg.textEdit_grav_ADMM_bounds.toPlainText():
            self.inversion_admm_grav_bounds = (
                self.dlg.textEdit_grav_ADMM_bounds.toPlainText()
            )
        if self.dlg.lineEdit_grav_ADMM_weight.text():
            self.inversion_admm_grav_weight = self.dlg.lineEdit_grav_ADMM_weight.text()
        if self.dlg.textEdit_5_magn_ADMM_bounds.toPlainText():
            self.inversion_admm_magn_bounds = (
                self.dlg.textEdit_5_magn_ADMM_bounds.toPlainText()
            )
        if self.dlg.lineEdit_magn_ADMM_weight.text():
            self.inversion_admm_magn_weight = self.dlg.lineEdit_magn_ADMM_weight.text()

        self.global_grav_dataUnitsMultiplier = (
            self.dlg.mQgsDoubleSpinBox_grav_data_multiplier.value()
        )
        self.global_grav_modelUnitsMultiplier = (
            self.dlg.mQgsDoubleSpinBox_grav_model_multiplier.value()
        )
        self.global_magn_dataUnitsMultiplier = (
            self.dlg.mQgsDoubleSpinBox_magn_data_multiplier.value()
        )
        self.global_magn_modelUnitsMultiplier = (
            self.dlg.mQgsDoubleSpinBox_magn_model_multiplier.value()
        )

        if self.dlg.radioButton_grav_inv.isChecked():  # grav
            self.inversion_type = 1
        elif self.dlg.radioButton_magn_inv.isChecked():  # mag
            self.inversion_type = 2
        else:  # mag_grav
            self.inversion_type = 3

        self.filename_grav = self.dlg.lineEdit_grav_data_path.text()
        self.filename_magn = self.dlg.lineEdit_magn_data_path.text()

        self.global_elevFilename = self.dlg.lineEdit_dtm_path.text()

        self.meshBox = {
            "south": self.dlg.mQgsSpinBox_mesh_south.value(),
            "west": self.dlg.mQgsSpinBox_mesh_west.value(),
            "north": self.dlg.mQgsSpinBox_mesh_north.value(),
            "east": self.dlg.mQgsSpinBox_mesh_east.value(),
        }

        self.forward_magneticField_declination = self.dlg.doubleSpinBox_mag_dec.value()
        self.forward_magneticField_inclination = self.dlg.doubleSpinBox_mag_inc.value()
        self.forward_magneticField_intensity = self.dlg.doubleSpinBox_mag_int.value()

        self.global_grav_sensor_height = (
            self.dlg.doubleSpinBox_grav_sensor_height.value()
        )
        self.global_magn_sensor_height = (
            self.dlg.doubleSpinBox_magn_sensor_height.value()
        )
        self.z_coreDepth = self.dlg.doubleSpinBox_coreDepth.value()
        self.z_fullDepth = self.dlg.doubleSpinBox_fullDepth.value()

    # load and parse existing parfile updating gui and storing parameters
    def load_parfile(self):

        #   set up dict with form
        #
        #   key=parfile variable name
        #   values=p[0] variable contents,
        #          p[1] associated widget(s),
        #          p[-2] data type,
        #          p[-1] widget type

        # parse parfile file and copy valid parameters to associated variables
        if os.path.exists(self.parfilename) and self.parfilename:
            parfile = open(self.parfilename, "r")

            for pl in parfile.readlines():
                pls = pl.split("=")
                pkey = (
                    pls[0].strip().replace("#", "")
                )  # replace() removes leading # to signify qgis parameter only

                if pkey in self.d_params.keys():  # if parameter found in dict

                    if len(pls) == 2:
                        pval = pls[1].strip()

                        if (
                            self.d_params[pkey][-2] == float
                        ):  # check for fortran 2d5.0 format floats
                            if "d" in pval:
                                pval = pval.replace("d", "e")

                        # assign value to parameter
                        if self.d_params[pkey][-1] == "size":
                            self.d_params[pkey][0][0] = self.d_params[pkey][-2](
                                pval.split(" ")[0]
                            )
                            self.d_params[pkey][0][1] = self.d_params[pkey][-2](
                                pval.split(" ")[1]
                            )
                            self.d_params[pkey][0][2] = self.d_params[pkey][-2](
                                pval.split(" ")[2]
                            )

                        else:
                            self.d_params[pkey][0] = self.d_params[pkey][-2](pval)

                        p = self.d_params[pkey]
                        if p[0] != "":
                            if p[-1] == "value":

                                p[1].setValue(p[-2](p[0]))
                            elif p[-1] == "plainText":
                                p[1].setText(p[-2](p[0]))
                            elif p[-1] == "text":
                                p[1].setText(p[-2](p[0]))
                            elif p[-1] == "epsg":
                                p[1].setCrs(QgsCoordinateReferenceSystem(p[-2](p[0])))
                            elif p[-1] == "check":
                                if p[0] == True:
                                    p[1].setChecked(True)
                                else:
                                    p[1].setChecked(False)
                            elif p[-1] == "radio":
                                for button in range(1, len(p) - 2):
                                    p[button].setChecked(False)
                                    if int(p[0]) == button:
                                        p[button].setChecked(True)

                            elif p[-1] == "path":
                                p[1] = p[0]
                            elif p[-1] == "size":
                                p[1].setText(p[-2](p[0][0]))
                                p[2].setText(p[-2](p[0][1]))
                                p[3].setText(p[-2](p[0][2]))

                        else:
                            print("blank", pkey)

            parfile.close()

    # reset params to deafults and update gui
    def reset_params(self):

        #   set up dict with form
        #
        #   key=parfile variable name
        #   values=p[0] variable contents,
        #          p[1] associated widget(s),
        #          p[-2] data type,
        #          p[-1] widget type

        # parse parfile file and copy valid parameters to associated variables

        self.initialise_variables()

        for pkey in self.d_params:

            p = self.d_params[pkey]

            if p[-1] == "value":
                p[1].setValue(p[-2](p[0]))
            elif p[-1] == "plainText":
                p[1].setText(p[-2](p[0]))
            elif p[-1] == "text":
                p[1].setText(p[-2](p[0]))
            elif p[-1] == "epsg":
                p[1].setCrs(QgsCoordinateReferenceSystem(p[-2](p[0])))
            elif p[-1] == "check":
                if p[0] == True:
                    p[1].setChecked(True)
                else:
                    p[1].setChecked(False)
            elif p[-1] == "radio":
                for button in range(1, len(p) - 2):
                    p[button].setChecked(False)
                    if int(p[0]) == button:
                        p[button].setChecked(True)

            elif p[-1] == "path":
                p[1] = p[0]
            elif p[-1] == "size":
                p[1].setText(p[-2](p[0][0]))
                p[2].setText(p[-2](p[0][1]))
                p[3].setText(p[-2](p[0][2]))
        self.enable_boxes()
        self.dlg.lineEdit_param_load_path.clear()
        self.dlg.groupBox_2.setEnabled(False)
        self.dlg.groupBox_3.setEnabled(False)
        self.dlg.groupBox_9.setEnabled(False)

    # update gui
    def enable_boxes(self):

        self.dlg.groupBox_16.setEnabled(True)
        self.dlg.groupBox_26.setEnabled(True)
        self.dlg.groupBox_22.setEnabled(True)
        self.dlg.groupBox_4.setEnabled(True)
        self.dlg.groupBox_28.setEnabled(True)
        self.dlg.groupBox_19.setEnabled(True)
        self.dlg.groupBox_25.setEnabled(True)
        if self.dataType == "raster":
            self.dlg.mQgsSpinBox_mesh_south.setEnabled(False)
            self.dlg.mQgsspinBox_grav_number_ADMM_litho.setEnabled(False)
            self.dlg.mQgsSpinBox_13.setEnabled(False)

        if self.global_experimentType == 1 or self.global_experimentType == 3:
            self.dlg.groupBox.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.groupBox_3.setEnabled(True)
            self.dlg.groupBox_2.setEnabled(True)
            self.dlg.groupBox_7.setEnabled(False)
            self.dlg.groupBox_10.setEnabled(False)

            self.dlg.groupBox_6.setEnabled(True)

            self.dlg.groupBox_29.setEnabled(False)
            self.dlg.groupBox_30.setEnabled(False)
            self.dlg.groupBox_23.setEnabled(False)

            self.dlg.groupBox_35.setEnabled(False)
            self.dlg.pushButton_load_grav_data.setEnabled(True)

        if self.global_experimentType == 2 or self.global_experimentType == 3:
            self.dlg.groupBox.setEnabled(False)
            self.dlg.groupBox_9.setEnabled(False)
            self.dlg.groupBox_3.setEnabled(False)
            self.dlg.groupBox_2.setEnabled(False)
            self.dlg.groupBox_7.setEnabled(True)
            self.dlg.groupBox_10.setEnabled(True)

            self.dlg.groupBox_6.setEnabled(True)

            self.dlg.groupBox_29.setEnabled(True)
            self.dlg.groupBox_30.setEnabled(True)
            self.dlg.groupBox_23.setEnabled(True)

            self.dlg.groupBox_35.setEnabled(True)
            self.dlg.pushButton_load_magn_data.setEnabled(True)

    # update elevation type based on gui
    def dtm_type(self):

        self.dlg.lineEdit_grav_data_path.setEnabled(True)
        self.dlg.pushButton_select_dtm_path.setEnabled(True)
        self.global_elevType = 2

    # update inversion type based on gui
    def inversion_type(self):
        # enable GroupBoxes

        if self.dlg.radioButton_grav_inv.isChecked():  # grav
            self.dlg.groupBox.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.groupBox_7.setEnabled(False)
            self.dlg.groupBox_10.setEnabled(False)

            self.dlg.groupBox_16.setEnabled(True)
            self.dlg.groupBox_26.setEnabled(True)
            self.dlg.groupBox_22.setEnabled(True)
            self.dlg.groupBox_6.setEnabled(True)

            self.dlg.groupBox_29.setEnabled(False)
            self.dlg.groupBox_30.setEnabled(False)
            self.dlg.groupBox_23.setEnabled(False)

            self.dlg.groupBox_35.setEnabled(False)
            self.global_experimentType = 1

        elif self.dlg.radioButton_magn_inv.isChecked():  # mag
            self.dlg.groupBox.setEnabled(False)
            self.dlg.groupBox_9.setEnabled(False)
            self.dlg.groupBox_7.setEnabled(True)
            self.dlg.pushButton_load_magn_data.setEnabled(False)
            self.dlg.groupBox_10.setEnabled(True)

            self.dlg.groupBox_16.setEnabled(False)
            self.dlg.groupBox_26.setEnabled(False)
            self.dlg.groupBox_22.setEnabled(False)

            self.dlg.groupBox_29.setEnabled(True)
            self.dlg.groupBox_30.setEnabled(True)
            self.dlg.groupBox_23.setEnabled(True)

            self.dlg.groupBox_35.setEnabled(True)
            self.global_experimentType = 2

        elif self.dlg.radioButton_joint_inv.isChecked():  # grav/mag
            self.dlg.groupBox.setEnabled(True)
            self.dlg.groupBox_9.setEnabled(True)
            self.dlg.groupBox_7.setEnabled(True)
            self.dlg.groupBox_10.setEnabled(True)

            self.dlg.groupBox_16.setEnabled(True)
            self.dlg.groupBox_26.setEnabled(True)
            self.dlg.groupBox_22.setEnabled(True)

            self.dlg.groupBox_29.setEnabled(True)
            self.dlg.groupBox_30.setEnabled(True)
            self.dlg.groupBox_23.setEnabled(True)

            self.dlg.groupBox_35.setEnabled(True)
            self.global_experimentType = 3

    # update mesh parameters to allow multiple layer thicknesses
    def mesh_layers(self):

        self.dlg.doubleSpinBox_coreDepth.setEnabled(True)
        self.dlg.doubleSpinBox_fullDepth.setEnabled(True)

    def define_tips(self):
        self.dlg.checkBox_read_sens_matrix.setToolTip(
            "Load previously calculated sensistivity matrix"
        )
        self.dlg.checkBox_use_compression.setToolTip(
            "Use wavelet compression to speed calculations and reduce memory demands of inversion"
        )
        self.dlg.checkBox_grav_depth_weighting.setToolTip(
            "Enable depth weighting for gravity inversion"
        )
        self.dlg.checkBox_magn_depth_weighting.setToolTip(
            "Enable depth weighting for magnetic inversion"
        )
        self.dlg.comboBox_grav_field_x.setToolTip(
            "Define column in csv file that contains Longitude/Easting information"
        )
        self.dlg.comboBox_grav_field_y.setToolTip(
            "Define column in csv file that contains Latitude/Northing information"
        )
        self.dlg.comboBox_grav_field_data.setToolTip(
            "Define column in csv file that contains Gravity information"
        )
        self.dlg.comboBox_magn_field_x.setToolTip(
            "Define column in csv file that contains Longitude/Easting information"
        )
        self.dlg.comboBox_magn_field_y.setToolTip(
            "Define column in csv file that contains Latitude/Northing information"
        )
        self.dlg.groupBox_10.setToolTip(
            "Define column in csv file that contains Magnetic information"
        )
        self.dlg.lineEdit_grav_ADMM_weight.setToolTip(
            "Define weighting of ADMM constraint"
        )
        self.dlg.lineEdit_magn_ADMM_weight.setToolTip(
            "Define weighting of ADMM constraint"
        )
        self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight.setToolTip(
            "Index of power term for depth weighting [3 for magnetics]"
        )
        self.dlg.mQgsDoubleSpinBox_grav_depth_weight_power.setToolTip(
            "Index of power term for depth weighting [2 for gravity]"
        )
        self.dlg.mQgsDoubleSpinBox_compression_ratio.setToolTip(
            "Amount of wavelt compression [smaller value means more compression]"
        )
        self.dlg.mQgsDoubleSpinBox_grav_model_multiplier.setToolTip(
            "Multiplier for scaling of output models"
        )
        self.dlg.mQgsDoubleSpinBox_grav_data_multiplier.setToolTip(
            "Multiplier for input gravity data to convert it to SI units"
        )
        self.dlg.mQgsDoubleSpinBox_grav_mmodel_norm_power.setToolTip(
            "Define power exponent of gravity model damping term"
        )
        self.dlg.mQgsDoubleSpinBox_grav_mmodel_damping_weight.setToolTip(
            "Define weight of gravity model damping term (m - m_prior)"
        )
        self.dlg.mQgsDoubleSpinBox_magn_model_multiplier.setToolTip(
            "Multiplier for scaling of output models"
        )
        self.dlg.mQgsDoubleSpinBox_magn_data_multiplier.setToolTip(
            "Multiplier for input magnetic data to convert it to SI units"
        )
        self.dlg.mQgsDoubleSpinBox_grav_weight.setToolTip(
            "Relative weighting of gravity data for joint inversion"
        )
        self.dlg.mQgsDoubleSpinBox_magn_weight.setToolTip(
            "Relative weighting of magnetic data for joint inversion"
        )
        self.dlg.mQgsDoubleSpinBox_magn_model_norm_power.setToolTip(
            "Define power exponent of magnetic model damping term"
        )
        self.dlg.mQgsDoubleSpinBox_magn_model_weight.setToolTip(
            "Define weight of magnetic model damping term (m - m_prior)"
        )
        self.dlg.label_61.setToolTip(
            "Define input gravity data projection system [EPSG:4326]"
        )
        self.dlg.label_62.setToolTip(
            "Define processed gravity data projection system [EPSG:4326]"
        )
        self.dlg.label_68.setToolTip(
            "Define input magnetic data projection system [EPSG:4326]"
        )
        self.dlg.label_71.setToolTip(
            "Define processed magnetic data projection system [EPSG:4326]"
        )
        self.dlg.mQgsSpinBox_mesh_south.setToolTip(
            "Define minimum Northing value for model grid (not taking into account the padding)"
        )
        self.dlg.mQgsSpinBox_mesh_east.setToolTip(
            "Define minimum Easting value for model grid (not taking into account the padding)"
        )
        self.dlg.mQgsSpinBox_mesh_west.setToolTip(
            "Define maximum Easting value for model grid (not taking into account the padding)"
        )
        self.dlg.mQgsSpinBox_mesh_north.setToolTip(
            "Define maximum Northing value for model grid (not taking into account the padding)"
        )
        self.dlg.mQgsSpinBox_mesh_size_x.setToolTip(
            "Define model grid x cell dimension"
        )
        self.dlg.mQgsSpinBox_mesh_size_y.setToolTip(
            "Define model grid x cell dimension"
        )
        self.dlg.mQgsSpinBox_mesh_padding.setToolTip(
            "Define uniform padding distance around model"
        )
        self.dlg.nx_label.setToolTip(
            "Number of model grid cells in the x direction (this will be calculated from the cell dimensions and model extents)"
        )
        self.dlg.ny_label.setToolTip(
            "Number of model grid cells in the y direction (this will be calculated from the cell dimensions and model extents)"
        )
        self.dlg.nz_label.setToolTip(
            "Number of model grid cells in the z direction (this will be calculated from the cell dimensions and model extents)"
        )
        self.dlg.memory_label.setToolTip(
            "Estimate of the memory required in GB to run the inversion, based on: 8 * nx * ny * nz * ndata * compression"
        )
        self.dlg.mQgsSpinBox_major_iters.setToolTip(
            "Number of major iterations of inversion to run, unless minimum residual value if data error is reached"
        )
        self.dlg.mQgsSpinBox_minor_iters.setToolTip(
            "Number of minor iterations of inversion to run per major iteration"
        )
        self.dlg.mQgsSpinBox_model_save_iters.setToolTip(
            "spacing between major iterations to save model outputs (0 means only save final model)"
        )
        self.dlg.lineEdit_output_directory_path_select.setToolTip(
            "Select or create directory that will store all data, model grid and parfiles, then process data, dtm and model grid files"
        )
        self.dlg.pushButton_select_dtm_path.setToolTip(
            "Load TIF format Digital Terrane Model"
        )
        self.dlg.pushButton_param_load_path.setToolTip(
            "Optional: Load existing parfile as the basis for updating an experiment"
        )
        self.dlg.pushButton_assign_magn_fields.setToolTip(
            "Assign x,y,data fields defined above"
        )
        self.dlg.pushButton_load_grav_data.setToolTip("Load gravity data as QGIS Layer")
        self.dlg.pushButton_save_paramfile.setToolTip(
            "Save out parameter file based on current dialog settings"
        )
        self.dlg.pushButton_load_magn_data.setToolTip(
            "Load magnetic data as QGIS Layer"
        )
        self.dlg.pushButton_grav_data_path.setToolTip(
            "Select a gravity dataset in csv, tif or ers format"
        )
        self.dlg.pushButton_magn_data_path.setToolTip(
            "Select a magnetic dataset in csv, tif or ers format"
        )
        self.dlg.pushButton_assign_grav_fields.setToolTip(
            "Assign x,y,data fields defined above"
        )
        self.dlg.radioButton_grav_inv.setToolTip(
            "Define parameters for gravity inversion experiemnt"
        )
        """self.dlg.radioButton_elev_const.setToolTip(
            "Assume constant elevaiton for ground surface"
        )"""
        """self.dlg.radioButton_elev_dtm.setToolTip(
            "Define ground topography by loading a TIF format Digital Terrane Model"
        )"""
        self.dlg.radioButton_magn_inv.setToolTip(
            "Define parameters for magnetic inversion experiemnt"
        )
        self.dlg.radioButton_joint_inv.setToolTip(
            "Define parameters for joint gravity-magnetic inversion experiemnt"
        )
        self.dlg.radioButton_magn_ADMM_depth_based.setToolTip(
            "Select depth-based ADMM constraints"
        )
        self.dlg.radioButton_magn_ADMM_dist_based.setToolTip(
            "Select distance-based ADMM constraints"
        )
        self.dlg.radioButton_grav_depth_based_ADMM.setToolTip(
            "Select depth-based ADMM constraints"
        )
        self.dlg.radioButton_grav_dist_based_ADMM.setToolTip(
            "Select distance-based ADMM constraints"
        )
        self.dlg.spinBox_grav_number_ADMM_litho.setToolTip(
            "Number of distinct pairs of ADMM density upper and lower bounds"
        )
        self.dlg.spinBox_magn_ADMM_number_litho.setToolTip(
            "Number of distinct pairs of ADMM magnetic susceptibility upper and lower bounds"
        )
        self.dlg.textEdit_experiment_description.setToolTip(
            "Provide free-form metadata for experiment"
        )
        self.dlg.textEdit_grav_ADMM_bounds.setToolTip(
            "Space separated pairs of upper and lower ADMM density bounds"
        )
        self.dlg.textEdit_min_residual.setToolTip(
            "Residual data error threshold before inversion stops"
        )
        self.dlg.textEdit_5_magn_ADMM_bounds.setToolTip(
            "Space separated pairs of upper and lower ADMM magnetic susceptibility bounds"
        )

        # ------------------------new tootips--------------------------------------------------
        self.dlg.doubleSpinBox_magn_sensor_height.setToolTip(
            "Height of mag sensor above DTM, assumes draped survey at const height"
        )
        self.dlg.doubleSpinBox_grav_sensor_height.setToolTip(
            "Height of grav sensor above DTM, assumes draped survey at const height"
        )
        self.dlg.dateEdit.setToolTip(
            "Date of Mag Survey, used for auto IGRF calculation"
        )
        self.dlg.lineEdit_ROI_path_select.setToolTip(
            "Load a shapefile to define x,y limts of Mesh (converts max/min extents of shape into a rectangle)"
        )
        self.dlg.pushButton_calc_IGRF.setToolTip(
            "Generates estimated Magnetic Field parameters based on height of sensor, date of survey and centroid of Mesh"
        )
        self.dlg.doubleSpinBox_mag_dec.setToolTip(
            "Manual overide of Magnetic Declination"
        )
        self.dlg.doubleSpinBox_mag_inc.setToolTip(
            "Manual overide of Magnetic Inclination"
        )
        self.dlg.doubleSpinBox_mag_int.setToolTip(
            "Manual overide of Magnetic Intensity"
        )
        
        self.dlg.pushButton_select_tomoPath.setToolTip(
            "Select path to tomofast executable, e.g. '/opt/homebrew/bin/tomofastx'"
        )
        self.dlg.pushButton_2_select_parfilePath.setToolTip(
            "Select a parfile to run the inversion (prefilled with the parfile created by this plugin)"
        )
        self.dlg.lineEdit_2_mpirunPath_2.setToolTip(   
            "Path to mpirun executable, if not in PATH, e.g. '/opt/homebrew/bin/mpirun' (MACOS Only)"
        )
        self.dlg.lineEdit_pre_command.setToolTip(   
            "Pre-command to run before inversion, e.g. 'wsl -e' (Windows WSL only)"
        )
        self.dlg.lineEdit_pre_command_2_WSL_Distro.setToolTip(
            "Name of WSL Distro to run the inversion in, e.g. 'Ubuntu-20.04' (Windows WSL only)"
        )
        self.dlg.mQgsSpinBox_noProc.setToolTip(
            "Number of processors to use for inversion (If more than 1 requires openmpi to be installed)"
        )
        self.dlg.pushButton_3_runInversion.setToolTip(
            "Run the inversion using the parameters defined in the parfile"
        )

    def show_version(self):
        metadata_path = os.path.dirname(os.path.realpath(__file__)) + "/metadata.txt"

        with open(metadata_path) as plugin_version_file:
            metadata = plugin_version_file.readlines()
            for line in metadata:
                parts = line.split("=")
                if len(parts) == 2 and parts[0] == "version":
                    plugin_version = parts[1]

            return plugin_version

    def initialise_variables(self):
        self.global_experimentType = 1
        self.modelGrid_grav_file = ""
        self.global_outputFolderPath = ""
        self.global_description = ""
        self.forward_data_grav_nData = 0
        self.forward_data_grav_dataGridFile = ""
        self.forward_data_grav_dataValuesFile = ""
        self.modelGrid_magn_file = ""
        self.forward_data_magn_nData = 0
        self.forward_data_magn_dataGridFile = ""
        self.forward_data_magn_dataValuesFile = ""
        self.forward_depthWeighting_grav_type = 1
        self.forward_depthWeighting_magn_type = 1
        self.forward_depthWeighting_grav_power = 2
        self.forward_depthWeighting_magn_power = 3
        self.sensit_readFromFiles = 0
        self.forward_matrixCompression_type = 1
        self.forward_matrixCompression_rate = 0.1
        self.inversion_priorModel_type = 0
        self.inversion_priorModel_grav_value = 0
        self.inversion_startingModel_type = 0
        self.inversion_startingModel_grav_value = 0
        self.inversion_nMajorIterations = 3
        self.inversion_nMinorIterations = 100
        self.inversion_writeModelEveryNiter = 0
        self.inversion_minResidual = 1e-13
        self.inversion_modelDamping_grav_weight = 0
        self.inversion_modelDamping_grav_normPower = 2
        self.inversion_modelDamping_magn_weight = 0
        self.inversion_modelDamping_magn_normPower = 2
        self.inversion_joint_grav_problemWeight = 1
        self.inversion_joint_magn_problemWeight = 0
        self.inversion_admm_grav_enableADMM = 0
        self.inversion_admm_grav_nLithologies = 1
        self.inversion_admm_grav_bounds = ""
        self.inversion_admm_grav_weight = 0
        self.inversion_admm_magn_enableADMM = 0
        self.inversion_admm_magn_nLithologies = 1
        self.inversion_admm_magn_bounds = ""
        self.inversion_admm_magn_weight = 0
        self.cell_x = 2000
        self.cell_y = 2000
        self.dz = 100
        self.padding = 10000
        self.z_coreDepth = 10000
        self.z_fullDepth = 20000
        self.filename_grav = ""
        self.filename_magn = ""
        self.grav_proj_in = "EPSG:4326"
        self.grav_proj_out = "EPSG:4326"
        self.magn_proj_in = "EPSG:4326"
        self.magn_proj_out = "EPSG:4326"
        self.global_elevType = 1
        self.global_elevFilename = ""
        self.modelGrid_size = [0, 0, 0]
        self.global_grav_dataUnitsMultiplier = -6
        self.global_magn_dataUnitsMultiplier = 1
        self.global_grav_modelUnitsMultiplier = 1
        self.global_magn_modelUnitsMultiplier = 1
        self.meshBox = {
            "south": 6730000,
            "west": 430000,
            "north": 6790000,
            "east": 482000,
        }

        self.magn_SurveyDay = 1
        self.magn_SurveyMonth = 1
        self.magn_SurveyYear = 2000
        self.forward_magneticField_declination = 0
        self.forward_magneticField_inclination = -45
        self.forward_magneticField_intensity = 65000
        self.dataType = "points"
        self.global_grav_sensor_height = 0
        self.global_magn_sensor_height = 0
        self.paramfile_Path = ""
        self.suffix_known = False
